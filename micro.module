<?php
// $Id: micro.module, v 1.0 2010/12/01 04:20:00 blup Exp $

/**
 * @file
 * Micro entity that attaches to other entities (or site)
 */

/**
 * Modules should return this value from hook_micro_access() to allow access to a micro.
 */
define('MICRO_ACCESS_ALLOW', 'allow');

/**
 * Modules should return this value from hook_micro_access() to deny access to a micro.
 */
define('MICRO_ACCESS_DENY', 'deny');

/**
 * Modules should return this value from hook_micro_access() to not affect micro access.
 */
define('MICRO_ACCESS_IGNORE', NULL);


//=============
//DRUPAL HOOKS.
//=============

/**
 * Implements hook_init().
 * TODO - token and actions files
 */
function micro_init() {
  $path = drupal_get_path('module', 'micro');
  //include_once $path .'/includes/micro.token.inc';
  if (module_exists('trigger')) {
    //include_once $path .'/includes/micro.actions.inc';
  }
}

/**
 * Implementation of hook_cron().
 * TODO
 */
function micro_cron() {
/*
 *  $expiration = variable_get('micro_expire', 0);
 *
 *  // Check if expiration is turned on
 *  if ($expiration > 0) {
 *    // Fetch shouts that have passed the expiration date
 *    $micro_items = db_query("SELECT * FROM {micro} WHERE created < %d", time() - (60 * 60 * 24 * $expiration));
 *    while ($micro = db_fetch_object($micro_items)) {
 *      // Delete the shout
 *      micro_delete_shout($micro);
 *    }
 *  }
 */
}

/**
 * Implementation of hook_help().
 */
function micro_help($path, $arg) {
  if ($path == 'admin/help#micro') {
    return t('Provides a new micro entity that can be attached to other entities.');
  }
}

/**
 * Implements hook_menu().
 */
function micro_menu() {
  $items['admin/content/micro'] = array(
    'title' => 'Micro',
    'description' => 'List and edit micro items.',
    'page callback' => 'micro_admin',
    'access arguments' => array('administer micro'),
    'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
    'file' => 'micro.admin.inc',
  );
  // Tabs begin here.
  /*
   *$items['admin/content/micro/new'] = array(
   *  'title' => 'Published comments',
   *  'type' => MENU_DEFAULT_LOCAL_TASK,
   *  'weight' => -10,
   *);
   *$items['admin/content/micro/approval'] = array(
   *  'title' => 'Unapproved comments',
   *  'title callback' => 'comment_count_unpublished',
   *  'page arguments' => array('approval'),
   *  'access arguments' => array('administer comments'),
   *  'type' => MENU_LOCAL_TASK,
   *);
   */
  $items['admin/structure/micro'] = array(
    'title' => 'Micro types',
    'description' => 'Manage content types, including default status, front page promotion, comment settings, etc.',
    'page callback' => 'micro_overview_types',
    'access arguments' => array('administer content types'),
    'file' => 'micro.admin.inc',
  );
  $items['admin/structure/micro/list'] = array(
    'title' => 'List micro types',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/structure/micro/add'] = array(
    'title' => 'Add micro type',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('micro_type_form'),
    'access arguments' => array('administer micro types'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'micro.admin.inc',
  );
  $items['admin/structure/micro/manage/%micro_type'] = array(
    'title' => 'Edit micro type',
    'title callback' => 'micro_type_page_title',
    'title arguments' => array(4),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('micro_type_form', 4),
    'access arguments' => array('administer micro types'),
    'file' => 'micro.admin.inc',
  );
  $items['admin/structure/types/manage/%micro_type/edit'] = array(
    'title' => 'Edit micro type',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/structure/types/manage/%micro_type/delete'] = array(
    'title' => 'Delete micro type',
    'page arguments' => array('micro_type_delete_confirm', 4),
    'access arguments' => array('administer micro types'),
    'file' => 'micro.admin.inc',
  );

  $items['micro'] = array(
    'page callback' => 'micro_page_default',
    'access arguments' => array('access micro items'),
    // Required to make 'micro/add' appear on the top-level of 'navigation' menu.
    'menu_name' => '',
    'type' => MENU_CALLBACK,
  );
  $items['micro/add'] = array(
    'title' => 'Add micro item',
    'page callback' => 'micro_add_page',
    'access callback' => '_micro_add_access',
    'menu_name' => 'navigation',
    'theme callback' => '_micro_custom_theme',
    'file' => 'micro.pages.inc',
  );
  /*
   *$items['micro-rss.xml'] = array(
   *  'title' => 'RSS feed',
   *  'page callback' => 'micro_feed',
   *  'access arguments' => array('access content'),
   *  'type' => MENU_CALLBACK,
   *);
   */
  drupal_static_reset('_micro_types_build');
  foreach (micro_type_get_types() as $type) {
    $type_url_str = str_replace('_', '-', $type->machine_name);
    $items['micro/add/' . $type_url_str] = array(
      'title' => $type->name,
      'title callback' => 'check_plain',
      'page callback' => 'micro_add',
      'page arguments' => array($type->machine_name),
      'access callback' => 'micro_access',
      'access arguments' => array('create', $type->machine_name),
      'description' => $type->description,
      'file' => 'micro.pages.inc',
    );
  }
  $items['micro/%micro'] = array(
    'title callback' => 'micro_page_title',
    'title arguments' => array(1),
    // The page callback also invokes drupal_set_title() in case
    // the menu router's title is overridden by a menu link.
    'page callback' => 'micro_page_view',
    'page arguments' => array(1),
    'access callback' => 'micro_access',
    'access arguments' => array('view', 1),
  );
  $items['micro/%micro/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['micro/%micro/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'micro_page_edit',
    'page arguments' => array(1),
    'access callback' => 'micro_access',
    'access arguments' => array('update', 1),
    'theme callback' => '_micro_custom_theme',
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'micro.pages.inc',
  );
  $items['micro/%micro/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('micro_delete_confirm', 1),
    'access callback' => 'micro_access',
    'access arguments' => array('delete', 1),
    'theme callback' => '_micro_custom_theme',
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'micro.pages.inc',
  );
  return $items;
}

/**
 * Implements hook_theme().
 */
function micro_theme() {
  return array(
    'micro' => array(
      'template' => 'micro',
      'render element' => 'elements',
    ),
    'micro_admin_type' => array(
      'variables' => array('name' => NULL, 'type' => NULL),
    ),
    'micro_admin_overview' => array(
      'variables' => array('name' => NULL, 'type' => NULL),
    ),
    'micro_wrapper' => array(
      'template' => 'micro-wrapper',
      'render element' => 'elements',
    ),
    'micro_linked_page_input' => array(
      'variables' => array('a' => null, 'b' => null, 'c' => null),
    ),
    'micro_ajax_form_input' => array(
      'variables' => array('a' => null, 'b' => null, 'c' => null),
    ),
    'micro_inline_form_input' => array(
      'variables' => array('form' => null),
    ),
  );
}
/**
 * Theme callback for creating and editing micro items.
 */
function _micro_custom_theme() {
  // Use the administration theme if the site is configured to use it for
  // micro items.
  if (variable_get('micro_admin_theme')) {
    return variable_get('admin_theme');
  }
}
/**
 * Implements hook_entity_info()
 * TODO - check
 */
function micro_entity_info() {
  $return = array(
    'micro' => array(
      'label' => t('Micro'),
      'entity class' => 'Micro',
      'controller class' => 'MicroController',
      'base table' => 'micro',
      'uri callback' => 'micro_uri',
      'fieldable' => TRUE,
      'view modes' => array(
        'account' => array(
          'label' => t('Micro stream'),
        ),
      ),
      'entity keys' => array(
        'id' => 'mid',
        'bundle' => 'type',
        'label' => 'mid',
      ),
      'bundles' => array(),
      'bundle keys' => array(
        'bundle' => 'machine_name',
      ),
    ),
  );

  $return['micro_type'] = array(
    'label' => t('Micro type'),
    'entity class' => 'MicroType',
    'controller class' => 'EntityAPIController',
    'base table' => 'micro_type',
    'fieldable' => FALSE,
    'bundle of' => 'micro',
    'exportable' => TRUE,
    'entity keys' => array(
      'id' => 'mtid',
      'name' => 'machine_name',
      'label' => 'name',
    ),
  );


  // Bundles must provide a human readable name so we can create help and error
  // messages, and the path to attach Field admin pages to.
  /*
   *foreach (micro_type_get_names() as $type => $name) {
   *  $return['micro']['bundles'][$type] = array(
   *    'label' => $name,
   *    'admin' => array(
   *      'path' => 'admin/structure/micro/manage/%micro_type',
   *      'real path' => 'admin/structure/micro/manage/' . str_replace('_', '-', $type),
   *      'bundle argument' => 4,
   *      'access arguments' => array('administer micro types'),
   *    ),
   *  );
   *}
   */

  return $return;
}

/**
 * Controller class for micro items.
 *
 * This extends the EntityAPIController class.
 */
class MicroController extends EntityAPIController {

  protected function buildQuery($ids, $conditions = array(), $revision_id = FALSE) {
    $query = parent::buildQuery($ids, $conditions, $revision_id);
    // Add the machine name field from the {micro_type} table.
    $query->innerJoin('micro_type', 'mt', 'base.mtid = mt.mtid');
    $query->addField('mt', 'machine_name', 'type');
    return $query;
  }
}
/**
 * Implements hook_comment_view().
 */
function micro_comment_view($comment) {
  $displays = micro_get_display($comment, $comment->cid);
  foreach ($displays as $key=>$value) {
    $comment->content[$key] = $value;
  }
}

/**
 * Implements hook_node_view().
 */
function micro_node_view($node, $view_mode) {
  $displays = micro_get_display($node, $node->nid, $view_mode);
  foreach ($displays as $key=>$value) {
    $node->content[$key] = $value;
  }
  dsm($node);
}

/**
 * Implements hook_node_insert().
 */
function micro_node_insert($node) {
  micro_node_save($node);
}

/**
 * Implements hook_node_update().
 */
function micro_node_update($node) {
  micro_node_save($node);
}

/**
 * Shared saving routine between micro_node_insert() and micro_node_update().
 */
function micro_node_save($node) {
  // Response to the micro checkboxes added to the form in micro_form_alter().
  /*
   *$remembered = FALSE;
   *$account = user_load($node->uid);
   *if (isset($node->micro)) {
   *  foreach ($node->micro as $name => $state) {
   *    $micro = micro_get_micro($name);
   *    // microging may trigger actions. We want actions to get the current
   *    // node, not a stale database-loaded one:
   *    if (!$remembered) {
   *      $micro->remember_content($node->nid, $node);
   *      // Actions may modify a node, and we don't want to overwrite this
   *      // modification:
   *      $remembered = TRUE;
   *    }
   *    micro($state ? 'micro' : 'unmicro', $name, $node->nid, $account, TRUE);
   *  }
   *}
   */
}

/**
 * Implements hook_node_delete().
 */
function micro_node_delete($node) {
  /*
   *foreach (micro_get_micro items('node') as $micro) {
   *  db_delete('micro')
   *    ->condition('type', $micro->machine_name)
   *    ->condition('mid', $micro->mid)
   *    ->condition('eid', $node->nid);
   *}
   */
}

/**
 * Implements hook_node_type().
 */
function micro_node_type_delete($info) {
  // Remove entry from micro-able content types.
  db_delete('micro_types')->condition('mtid', $info->mtid)->execute();
}

/**
 * Implements hook_user_cancel().
 */
function micro_user_cancel(&$edit, $account, $method) {
  // Delete all micro items of the user in any case.
  foreach (micro_load_by_user($account) as $micro) {
    micro_delete($micro);
  }
}
/**
 * Implements hook_user_view().
 */
function micro_user_view($account) {
  foreach (micro_type_get_types() as $type => $micro_type) {
    if ($micro_type->userView && ($micro = micro_load_by_user($account, $type))) {
      $account->content['micro_' . $type] = array(
        '#type' => 'user_micro_category',
        '#title' => $micro->name,
      );
      $account->content['micro_' . $type] += field_attach_view('micro', $micro, 'account');
    }
  }
}

/**
 * Implements hook_forms().
 * All micro forms share the same form handler.
 */
function micro_forms() {
  $forms = array();
  if ($types = micro_type_get_types()) {
    foreach (array_keys($types) as $type) {
      $forms[$type . '_micro_form']['callback'] = 'micro_form';
    }
  }
  return $forms;
}


//==========
//MICRO API.
//==========

/**
 * Menu title callback.
 */
function micro_type_page_title($micro_type) {
  return $micro_type->machine_name;
}

/**
 * Implements hook_permission().
 */
function micro_permission() {
  $permissions = array(
    'bypass micro access' =>  array(
      'title' => t('Bypass micro access'),
      'description' => t('Bypass all access permissions for micro items.'),
    ),
    'access micro items' =>  array(
      'title' => t('Access micro items'),
      'description' => t('Access micro items.'),
    ),
    'administer micro types' =>  array(
      'title' => t('Administer micro types'),
      'description' => t('Create and delete fields for micro types.'),
    ),
    'administer micro items' =>  array(
      'title' => t('Administer micro items'),
      'description' => t('Edit and view all micro items.'),
    ),
   'view micro items attached to own content' => array(
      'title' => t('View attached items'),
      'description' => t('View micro items attached to own content.'),
    ),
   'edit micro items attached to own content' => array(
      'title' => t('Edit attached items'),
      'description' => t('Edit micro items attached to own content.'),
    ),
   'delete micro items attached to own content' => array(
      'title' => t('Delete attached items'),
      'description' => t('Delete micro items attached to own content.'),
    ),
  );
  // Generate per micro type permissions.
  foreach (micro_type_get_types() as $type) {
    $type_name = check_plain($type->machine_name);
    $permissions += array(
      "edit own $type_name micro items" => array(
        'title' => t('Edit own %type_name micro', array('%type_name' => $type->name)),
      ),
      "edit any $type_name micro items" => array(
        'title' => t('Edit any %type_name micro', array('%type_name' => $type->name)),
      ),
      "view own $type_name micro items" => array(
        'title' => t('View own %type_name micro', array('%type_name' => $type->name)),
      ),
      "view any $type_name micro items" => array(
        'title' => t('View any %type_name micro', array('%type_name' => $type->name)),
      ),
    );
  }
  return $permissions;
}

/**
 * Fetch micro items by account.
 *
 * @param $account
 *   The user account to load micro items for, or its uid.
 * @param $type
 *   To load a single micro, pass the type of the micro to load.
 * @return
 *   Either a single micro or an array of micro items keyed by micro type.
 *
 * @see micro_load_multiple()
 */
function micro_load_by_user($account, $type = NULL) {
  // Use a separate query to determine all micro ids per user and cache them.
  // That way we can look up micro items by id and benefit from the static cache
  // of the entity loader.
  $cache = drupal_static(__FUNCTION__, array());
  $uid = is_object($account) ? $account->uid : $account;

  if (!isset($cache[$uid])) {
    if (empty($type)) {
      $micro_items = micro_load_multiple(array(), array('uid' => $uid));
      // Cache ids for further lookups.
      $cache[$uid] = array();
      foreach ($micro_items as $mid => $micro) {
        $cache[$uid][$micro->machine_name] = $mid;
      }
      return array_combine(array_keys($cache[$uid]), $micro_items);
    }
    $cache[$uid] = db_select('micro', 'm')
      ->fields('m', array('type', 'mid'))
      ->condition('uid', $uid)
      ->execute()
      ->fetchAllKeyed();
  }
  if (isset($type)) {
    return isset($cache[$uid][$type]) ? micro_load($cache[$uid][$type]) : FALSE;
  }
  // Return an array containing micro items keyed by micro type.
  return $cache[$uid] ? array_combine(array_keys($cache[$uid]), micro_load_multiple($cache[$uid])) : $cache[$uid];
}

/**
 * Deletes a micro.
 */
function micro_delete(Micro $micro) {
  $micro->delete();
}

/**
 * Delete multiple micro items.
 *
 * @param $mids
 *   An array of micro IDs.
 */
function micro_delete_multiple(array $mids) {
  entity_get_controller('micro')->delete($mids);
}

/**
 * Create a new micro object.
 */
function micro_create(array $values) {
  return new Micro($values);
}

/**
 * Saves a micro to the database.
 *
 * @param $micro
 *   The micro object.
 */
function micro_save(Micro $micro) {
  return $micro->save();
}

/**
 * Saves a micro type to the db.
 */

function micro_type_save(MicroType $type) {
  $type = micro_type_set_defaults($type);
  $type->save();
  drupal_static_reset('_micro_types_build');
}

/**
 * Deletes a micro type from the db.
 */
function micro_type_delete(MicroType $type) {
  $type->delete();
  drupal_static_reset('_micro_types_build');
}

/**
 * Implements hook_micro_type_delete()
 */
function micro_micro_type_delete($type) {
  // Delete all micro items of this type.
  $mids = array_keys(micro_load_multiple(FALSE, array('mtid' => $type->mtid)));
  micro_delete_multiple($mids);
}

/**
 * The class used for micro entities.
 */
class Micro extends EntityDBExtendable {

  public function __construct($values = array()) {
    parent::__construct($values, 'micro');
  }
}

/**
 * Use a separate class for micro types so we can specify some defaults
 * modules may alter.
 * TODO - change variables
 */

class MicroType extends EntityDBExtendable {


  /**
   * Whether the micro type appears in the user categories.
   */

  /*
   *public $userCategory = TRUE;
   */


  /**
   * Whether the micro is displayed on the user account page.
   */

  /*
   *public $userView = TRUE;
   */


  public $type;
  public $name;
  public $weight = 0;

  public function __construct($values = array()) {
    parent::__construct($values, 'micro_type');
  }


  /**
   * Returns whether the micro type is locked, thus may not be deleted or renamed.
   *
   * Micro types provided in code are automatically treated as locked, as well
   * as any fixed micro type.
   */

  public function isLocked() {
    return isset($this->status) && (($this->status & ENTITY_IN_CODE) || ($this->status & ENTITY_FIXED));
  }
}

/**
 * Implements hook_entity_info_alter().
 *
 * Use this hook to specify profile bundles to avoid a recursion, as loading
 * the profile types needs the entity info too.
 */
function micro_entity_info_alter(&$entity_info) {
  foreach (micro_type_get_types() as $type => $info) {
    $entity_info['micro']['bundles'][$type] = array(
      'label' => $info->name,
      'admin' => array(
        'path' => 'admin/structure/micro/manage/%micro_type',
        'real path' => 'admin/structure/micro/manage/' . $type,
        'bundle argument' => 4,
        'access arguments' => array('administer micro'),
      ),
    );
  }
}
/**
 * Implements hook_default_micro_type().
 */
function micro_default_micro_type() {
  $types['main'] = new MicroType(array(
      'type' => 'main',
      'name' => t('Micro'),
      'weight' => 0,
  ));
  return $types;
}

/**
 * Determine whether a micro hook exists.
 *
 * @param $micro
 *   A micro object or a string containing the micro type.
 * @param $hook
 *   A string containing the name of the hook.
 * @return
 *   TRUE if the $hook exists in the micro type of $micro.
 */
function micro_hook($micro, $hook) {
  $base = micro_type_get_base($micro);
  return module_hook($base, $hook);
}

/**
 * Invoke a micro hook.
 *
 * @param $micro
 *   A micro object or a string containing the micro type.
 * @param $hook
 *   A string containing the name of the hook.
 * @param $a2, $a3, $a4
 *   Arguments to pass on to the hook, after the $micro argument.
 * @return
 *   The returned value of the invoked hook.
 */
function micro_invoke($micro, $hook, $a2 = NULL, $a3 = NULL, $a4 = NULL) {
  if (micro_hook($micro, $hook)) {
    $base = micro_type_get_base($micro);
    $function = $base . '_' . $hook;
    return ($function($micro, $a2, $a3, $a4));
  }
}

/**
 * Load micro entities from the database.
 *
 * This function should be used whenever you need to load more than one micro
 * from the database. Micro items are loaded into memory and will not require
 * database access if loaded again during the same page request.
 *
 * @see entity_load()
 *
 * @param $mids
 *   An array of micro IDs.
 * @param $conditions
 *   An array of conditions on the {micro} table in the form 'field' => $value.
 * @param $reset
 *   Whether to reset the internal micro_load cache.
 *
 * @return
 *   An array of micro objects indexed by mid.
 */
function micro_load_multiple($mids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('micro', $mids, $conditions, $reset);
}

/**
 * Load a micro object from the database.
 *
 * @param $mid
 *   The micro ID.
 * @param $vid
 *   The revision ID.
 * @param $reset
 *   Whether to reset the micro_load_multiple cache.
 *
 * @return
 *   A fully-populated micro object.
 */
function micro_load($mid = NULL, $reset = FALSE) {
  $mids = (isset($mid) ? array($mid) : array());
  $micro = micro_load_multiple($mids, $reset);
  return $micro ? reset($micro) : FALSE;
}

/**
 * Prepares a micro object for editing.
 *
 * Fills in a few default values, and then invokes hook_prepare() on the micro
 * type module, and hook_micro_prepare() on all modules.
 */
function micro_object_prepare($micro) {
  dsm($micro);
  // Set up default values, if required.
  //TODO - default options?
  /*
   *$micro_options = variable_get('micro_options_' . $micro->machine_name, array());
   */
  // If this is a new micro, fill in the default values.
  if (!isset($micro->mid) || isset($micro->is_new)) {
    global $user;
    $micro->uid = $user->uid;
    $micro->created = REQUEST_TIME;
  }
  else {
    $micro->date = format_date($micro->created, 'custom', 'Y-m-d H:i:s O');
  }

  micro_invoke($micro, 'prepare');
  module_invoke_all('micro_prepare', $micro);
}

/**
 * Perform validation checks on the given micro.
 */
function micro_validate($micro, $form, &$form_state) {
  $type = micro_type_get_type($micro);

  // Invoke hook_validate() for micro type specific validation and
  // hook_micro_validate() for miscellaneous validation needed by modules. Can't
  // use micro_invoke() or module_invoke_all(), because $form_state must be
  // receivable by reference.
  $function = micro_type_get_base($micro) . '_validate';
  if (function_exists($function)) {
    $function($micro, $form, $form_state);
  }
  foreach (module_implements('micro_validate') as $module) {
    $function = $module . '_micro_validate';
    $function($micro, $form, $form_state);
  }
}

/**
 * Prepare micro for saving by populating author and creation date.
 */
function micro_submit($micro) {
  global $user;
dsm($micro);
  $micro->uid = $user->uid;
  $micro->name = $user->name;
  $micro->created = REQUEST_TIME;
  $micro->validated = TRUE;

  return $micro;
}

/**
 * Generate an array for rendering the given micro.
 *
 * @param $micro
 *   A micro object.
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 *
 * @return
 *   An array as expected by drupal_render().
 */
function micro_view($micro, $view_mode = 'full') {
  // Populate $micro->content with a render() array.
  micro_build_content($micro, $view_mode);
  $micro_type = micro_type_get_type($micro);
  $entity = entity_load($micro_type->entity, array($micro->eid));

  $build = $micro->content;
  // We don't need duplicate rendering info in micro->content.
  unset($micro->content);

  $build += array(
    '#theme' => 'micro',
    '#micro' => $micro,
    '#entity' => reset($entity),
    '#attached_entity_type' => $micro_type->entity,
    '#view_mode' => $view_mode,
  );

  //TODO - test
  // Add contextual links for this micro, except when the micro is already being
  // displayed on its own page. Modules may alter this behavior (for example,
  // to restrict contextual links to certain view modes) by implementing
  // hook_micro_view_alter().
  if (!empty($micro->mid) && !($view_mode == 'full' && micro_is_page($micro))) {
    $build['#contextual_links']['micro'] = array('micro', array($micro->mid));
  }

  // Allow modules to modify the structured micro.
  drupal_alter('micro_view', $build);
  return $build;
}

/**
 * Builds a structured array representing the micro's content.
 *
 * The content built for the micro (field values, comments, file attachments or
 * other micro components) will vary depending on the $view_mode parameter.
 *
 * Micro defines the following view modes for micro items, with the following
 * default use cases:
 *   - short (default): micro is being displayed within its parent entity
 *   - full: micro is being displayed on its own page (micro/123)
 *
 * Contributed modules might define additional view modes, or use existing
 * view modes in additional contexts.
 *
 * @param $micro
 *   A micro object.
 * @param $view_mode
 *   View mode, e.g. 'full', 'short'...
 */
function micro_build_content($micro, $view_mode = 'short') {
  // Remove previously built content, if exists.
  $micro->content = array();

  // The 'view' hook can be implemented to overwrite the default function
  // to display micro items.
  if (micro_hook($micro, 'view')) {
    $micro = micro_invoke($micro, 'view', $view_mode);
  }

  // Build fields content.
  // In case of a multiple view, micro_view_multiple() already ran the
  // 'prepare_view' step. An internal flag prevents the operation from running
  // twice.
  field_attach_prepare_view('micro', array($micro->mid => $micro), $view_mode);
  entity_prepare_view('micro', array($micro->mid => $micro));
  $micro->content += field_attach_view('micro', $micro, $view_mode);

  $links = array();
  //TODO - theme callback
  $micro->content['links'] = array(
    '#theme' => 'links__micro',
    '#links' => $links,
    '#attributes' => array('class' => array('links', 'inline')),
  );

  // Allow modules to make their own additions to the micro.
  module_invoke_all('micro_view', $micro, $view_mode);
}

/**
 * Returns whether the current page is the full page view of the passed in micro.
 *
 * @param $micro
 *   A micro object.
 */
function micro_is_page($micro) {
  $page_element = menu_get_object();
  return (!empty($page_element) ? (isset($page_element->mid) && $page_element->mid == $micro->mid) : FALSE);
}
/**
 * Determine whether the current user may perform the given operation on the
 * specified micro.
 *
 * @param $op
 *   The operation to be performed on the micro. Possible values are:
 *   - "view"
 *   - "update"
 *   - "delete"
 *   - "create"
 * @param $micro
 *   The micro object on which the operation is to be performed, or micro type
 *   for "create" operation.
 * @param $account
 *   Optional, a user object representing the user for whom the operation is to
 *   be performed. Determines access for a user other than the current user.
 * @return
 *   TRUE if the operation may be performed, FALSE otherwise.
 */
function micro_access($op, $micro, $account = NULL) {
  global $user;

  $rights = &drupal_static(__FUNCTION__, array());

  if (!$micro || !in_array($op, array('view', 'update', 'delete', 'create'), TRUE)) {
    // If there was no micro to check against, or the $op was not one of the
    // supported ones, we return access denied.
    return FALSE;
  }
  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $user;
  }

  // $micro may be either an object or a micro type. Since micro types cannot be
  // an integer, use either mid or type as the static cache id.

  $cid = is_object($micro) ? $micro->mid : $micro;

  // If we've already checked access for this micro, user and op, return from
  // cache.
  if (isset($rights[$account->uid][$cid][$op])) {
    return $rights[$account->uid][$cid][$op];
  }

  if (user_access('bypass micro access', $account)) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }
  if (!user_access('access micro content', $account)) {
    $rights[$account->uid][$cid][$op] = FALSE;
    return FALSE;
  }

  // We grant access to the micro if both of the following conditions are met:
  // - No modules say to deny access.
  // - At least one module says to grant access.
  // If no module specified either allow or deny, we fall back to the defaults.
  $access = module_invoke_all('micro_access', $micro, $op, $account);
  if (in_array(MICRO_ACCESS_DENY, $access, TRUE)) {
    $rights[$account->uid][$cid][$op] = FALSE;
    return FALSE;
  }
  elseif (in_array(MICRO_ACCESS_ALLOW, $access, TRUE)) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }

  if($op != 'create' && $micro->mid) {
    // Check whether the author is allowed to view/edit/delete their own micro items.
    if ($account->uid == $micro->uid && user_access($op . ' own micro items', $account) && $account->uid != 0) {
      $rights[$account->uid][$cid][$op] = TRUE;
      return TRUE;
    }
    // Check for the following cases:
    // - If editing/deleting, check whether the user has permission and access to the operation on the entity.
    // - If viewing and the micro item is not private, check whether the user has access to view the entity.
    // - If viewing and the micro item is private, check whether the user viewing is the author of the entity it's attached to.
    elseif (($op != 'view' && user_access($op . ' micro items attached to own content', $account->uid)) || ($op == 'view')) {
      $micro_type = micro_type_get_type($micro);
      switch ($micro->entity) {
        case 'node':
          $entity = node_load($micro->eid);
          if (($op !== 'view' && node_access($op, $entity, $user)) ||
              ($op == 'view' && !$micro_type->data['private'] && node_access($op, $entity, $user)) ||
              ($op == 'view' && $micro_type->data['private'] && $account->uid == $entity->uid)) {
            $rights[$account->uid][$cid][$op] = TRUE;
            return TRUE;
          }
          break;
        case 'user':
          $entity = user_load($micro->eid);
          if (($op !== 'view' && user_edit_access($entity)) ||
              ($op == 'view' && !variable_get('micro_private_' . $micro_type->machine_name, 0) && user_view_access($entity)) ||
              ($op == 'view' && variable_get('micro_private_' . $micro_type->machine_name, 0) && $account->uid == $entity->uid)) {
            $rights[$account->uid][$cid][$op] = TRUE;
            return TRUE;
          }
          break;
        case 'comment':
          $entity = comment_load($micro->eid);
          if (($op !== 'view' && comment_access($op, $entity)) ||
              ($op == 'view' && !variable_get('micro_private_' . $micro_type->machine_name, 0) && comment_access($op, $entity)) ||
              ($op == 'view' && variable_get('micro_private_' . $micro_type->machine_name, 0) && $account->uid == $entity->uid)) {
            $rights[$account->uid][$cid][$op] = TRUE;
            return TRUE;
          }
          break;
        case 'taxonomy':
          $vocabulary = taxonomy_get_vocabulary($micro->eid);
          // Micro items attached to taxonomy terms cannot be private
          if (($op !== 'view' && user_access($op . ' terms ' . ($op == 'edit' ? 'in ' : 'from ') . $vocabulary)) ||
              ($op == 'view')) {
            $rights[$account->uid][$cid][$op] = TRUE;
            return TRUE;
          }
          break;
        default:
          //TODO - not sure what else to add here
          if ($op == 'view') {
            return TRUE;
          }
          break;
      }
    }
  }

  return FALSE;
}

/**
 * Implements hook_micro_access().
 */
function micro_micro_access($micro, $op, $account) {
  $type = is_string($micro) ? $micro : $micro->machine_name;

  if (in_array($type, micro_type_get_types())) {
    if ($op == 'create' && user_access('create ' . $type . ' content', $account)) {
      return MICRO_ACCESS_ALLOW;
    }

    if ($op == 'update') {
      if (user_access('edit any ' . $type . ' content', $account) || (user_access('edit own ' . $type . ' content', $account) && ($account->uid == $micro->uid))) {
        return MICRO_ACCESS_ALLOW;
      }
    }

    if ($op == 'delete') {
      if (user_access('delete any ' . $type . ' content', $account) || (user_access('delete own ' . $type . ' content', $account) && ($account->uid == $micro->uid))) {
        return MICRO_ACCESS_ALLOW;
      }
    }
  }

  return MICRO_ACCESS_IGNORE;
}

function _micro_add_access() {
  $types = micro_type_get_types();
  foreach ($types as $type) {
    if (micro_hook($type->machine_name, 'form') && micro_access('create', $type->machine_name)) {
      return TRUE;
    }
  }
  if (user_access('administer micro types')) {
    // There are no content types defined that the user has permission to create,
    // but the user does have the permission to administer the content types, so
    // grant them access to the page anyway.
    return TRUE;
  }
  return FALSE;
}
function micro_load_from_type($mtid, $eid, $reset = FALSE) {
  $conditions = array('mtid' => $mtid, 'eid' => $eid);
  return entity_load('micro', FALSE, $conditions, $reset);
}


//=================
//HELPER FUNCTIONS.
//=================

/**
 * Entity uri callback.
 */
function micro_uri($micro) {
  return array(
    'path' => 'micro/' . $micro->mid,
  );
}
function micro_page_title($micro) {
  return isset($micro->mid) ? $micro->mid : '';
}
/**
 * Returns a list of all the available micro types.
 *
 * This list can include types that are queued for addition or deletion.
 * See _micro_types_build() for details.
 *
 * @return
 *   An array of micro types, keyed by the type.
 *
 * @see micro_type_get_type()
 */
function micro_type_get_types() {
  return _micro_types_build()->types;
}

/**
 * Returns the micro type of the passed micro or micro type string.
 *
 * @param $micro
 *   A micro object or string that indicates the micro type to return.
 *
 * @return
 *   A single micro type, as an object, or FALSE if the micro type is not found.
 *   The micro type is an object containing fields from hook_micro_info() return
 *   values, as well as the field 'type' (the machine-readable type) and other
 *   fields used internally and defined in _micro_types_build(),
 *   hook_micro_info(), and micro_type_set_defaults().
 */
function micro_type_get_type($micro, $object = TRUE) {
  if (is_object($micro) || is_numeric($micro)) {
    dsm($micro);
    $id = is_object($micro) ? $micro->mtid : $micro;
    $types = _micro_types_build()->ids;
    return isset($types[$id]) ? ($object ? $types[$id] : $types[$id]->machine_name) : FALSE;
  }
  else {
    $types = _micro_types_build()->types;
    return isset($types[$micro]) ? ($object ? $types[$micro] : $types[$micro]->machine_name) : FALSE;
  }
}

/**
 * Returns the micro type base of the passed micro or micro type string.
 *
 * The base indicates which module implements this micro type and is used to
 * execute micro-type-specific hooks. For types defined in the user interface
 * and managed by micro.module, the base is 'micro_content'.
 *
 * @param $micro
 *   A micro object or string that indicates the micro type to return.
 *
 * @return
 *   The micro type base or FALSE if the micro type is not found.
 *
 * @see micro_invoke()
 */
function micro_type_get_base($micro) {
  if (is_object($micro) || is_numeric($micro)) {
    $id = is_object($micro) ? $micro->mtid : $micro;
    dsm($micro);
    $types = _micro_types_build()->ids;
    return isset($types[$id]) && isset($types[$id]->base) ? $types[$id]->base : FALSE;
  }
  else {
    $types = _micro_types_build()->types;
    return isset($types[$micro]) && isset($types[$micro]->base) ? $types[$micro]->base : FALSE;
  }
}

/**
 * Returns a list of available micro type names.
 *
 * This list can include types that are queued for addition or deletion.
 * See _micro_types_build() for details.
 *
 * @return
 *   An array of micro type names, keyed by the type.
 */
function micro_type_get_names() {
  return _micro_types_build()->names;
}

/**
 * Returns the micro type name of the passed micro or micro type string.
 *
 * @param $micro
 *   A micro object or string that indicates the micro type to return.
 *
 * @return
 *   The micro type name or FALSE if the micro type is not found.
 */
function micro_type_get_name($micro) {
  if (is_object($micro) || is_numeric($micro)) {
    $id = is_object($micro) ? $micro->mtid : $micro;
    $types = _micro_types_build()->ids;
    return isset($names[$id]) && isset($types[$id]->name) ? $types[$id]->name : FALSE;
  }
  else {
    $names = _micro_types_build()->names;
    return isset($names[$micro]) ? $names[$micro] : FALSE;
  }
}

/**
 * Updates the database cache of micro types.
 *
 * All new module-defined micro types are saved to the database via a call to
 * micro_type_save(), and obsolete ones are deleted via a call to
 * micro_type_delete(). See _micro_types_build() for an explanation of the new
 * and obsolete types.
 */
function micro_types_rebuild() {
  _micro_types_build(TRUE);
}

/**
 * Menu argument loader: loads a micro type by string.
 *
 * @param $name
 *   The machine-readable name of a micro type to load, where '_' is replaced
 *   with '-'.
 *
 * @return
 *   A micro type object or FALSE if $name does not exist.
 */
function micro_type_load($name) {
  return micro_type_get_type(strtr($name, array('-' => '_')));
}

/**
 * Set the default values for a micro type.
 *
 * The defaults are for a type defined through hook_micro_info().
 *
 * @param $info
 *   An object or array containing values to override the defaults.
 *
 * @return
 *  A micro type object.
 */
function micro_type_set_defaults($info = array()) {
  $type = &drupal_static(__FUNCTION__);

  if (!isset($type)) {
    $type = new MicroType();
    $type->machine_name = '';
    $type->name = '';
    $type->base = '';
    $type->description = '';
    $type->disabled = 0;
    $type->is_new = 1;
  }
  $new_type = clone $type;
  //TODO
  //$info = (array) $info;
  foreach ($info as $key => $data) {
    $new_type->$key = $data;
  }
  if (empty($new_type->module)) {
    $new_type->module = $new_type->base == 'micro_content' ? 'micro' : '';
  }

  return $new_type;
}

/**
 * Content type checking to see if a micro applies to a certain type of data.
 *
 * @param $micro
 *   The micro object whose available types are being checked.
 * @param $entity
 *   The entity being checked, usually "node".
 * @param $bundle
 *   The subtype being checked.
 *
 * @return
 *   Boolean TRUE if the micro is enabled for this entity and bundle.
 *   FALSE otherwise.
 */
function micro_content_enabled($micro_type, $entity, $bundle = NULL) {
  $return = $micro_type->entity == $entity && (!isset($bundle) || in_array($bundle, $micro_type->bundles));
  return $return;
}

/**
 * List all micro items available.
 *
 * If entity type or account are entered, a list of all possible micro items will be
 * returned.
 *
 * @param $entity
 *   Optional. The type of entity for which to load the micro items. Usually 'node'.
 * @param $bundle
 *   Optional. The the entity bundle for which to load the micro items.
 * @param $account
 *   Optional. The user account to filter available micro items. If not set, all
 *   micro types for this entity/bundle will be returned.
 * @param $reset
 *   Optional. Reset the internal query cache.
 *
 * @return $micro_types
 *   An array of the micro types.
 */
function micro_get_micro_types($entity = NULL, $bundle = NULL, $account = NULL, $reset = FALSE) {
  static $micro_types;

  // Retrieve a list of all micro_types, regardless of the parameters.
  if (!isset($micro_types) || $reset) {
    $micro_types = micro_get_types();

    // Add code-based micro_types provided by modules.
    $default_micro_types = micro_get_default_micro_types();
    foreach ($default_micro_types as $name => $default_micro) {
      // Insert new enabled micro_types into the database to give them an FID.
      if ($default_micro->status && !isset($micro_types[$name])) {
        $default_micro->save();
        $micro_types[$name] = $default_micro;
      }

      if (isset($micro_types[$name])) {
        // Ensure overridden micro_types are associated with their parent module.
        $micro_types[$name]->module = $default_micro->module;
      }
    }

    // Allow modules implementing hook_micro_alter(&$micro_types) and hook_micro_TYPE_alter(&$micro_type) to modify each micro.
    drupal_alter('micro', $micro_types);
    foreach ($micro_types as $micro_type) {
      drupal_alter('micro_' . $micro_type->machine_name, $micro_type);
    }
  }

  // Make a variable copy to filter types and account.
  $filtered_micro_types = $micro_types;

  // Filter out micro_types based on entity and bundle.
  if (isset($entity) || isset($bundle)) {
    foreach ($filtered_micro_types as $name => $micro_type) {
      if (!micro_content_enabled($micro_type, $entity, $bundle)) {
        unset($filtered_micro_types[$name]);
      }
    }
  }

  // Filter out micro_types based on account permissions.
  if (isset($account) && $account->uid != 1) {
    foreach ($filtered_micro_types as $name => $micro_type) {
      if (!micro_access($micro_type, $account)) {
        unset($filtered_micro_types[$name]);
      }
    }
  }

  return $filtered_micro_types;
}

/**
 * Builds all information on input types and formatter types for micro items.
 *
 * @param $reset
 *   If TRUE, clear the cache. The information will be rebuilt from the database
 *   next time it is needed. Defaults to FALSE.
 *
 * @return
 *   If $reset is TRUE, nothing.
 *   If $reset is FALSE, an array containing the following elements:
 *   - 'input types': Array of hook_micro_input_info() results, keyed by
 *     input_type. Each element has the following components: label, micro
 *     types, settings, and behaviors from hook_micro_input_info(), as well
 *     as module, giving the module that exposes the input type.
 *   - 'display types': Array of hook_micro_display_info() results, keyed by
 *     display_type. Each element has the following components: label, micro
 *     types, and behaviors from hook_micro_display_info(), as well as
 *     module, giving the module that exposes the display type.
 */
function _micro_displays_build($reset = FALSE) {
  static $info;

  if ($reset) {
    $info = NULL;
    variable_del("micro_display_types");
    return;
  }

  if (!isset($info)) {
    //TODO
      if($cached = variable_get("micro_view_types")) {
      $info = $cached->data;
    }
    else {
      $info = array(
        'input_types' => array(),
        'display_types' => array(),
      );

      // Populate input types.
      foreach (module_implements('micro_input_info') as $module) {
        $input_types = (array) module_invoke($module, 'micro_input_info');
        foreach ($input_types as $name => $input_info) {
          // Provide defaults.
          $input_info += array(
            'settings' => array(),
          );
          $info['input_types'][$name] = $input_info;
          $info['input_types'][$name]['module'] = $module;
        }
      }
      drupal_alter('micro_input_info', $info['input_types']);

      // Populate display types.
      foreach (module_implements('micro_display_info') as $module) {
        $display_types = (array) module_invoke($module, 'micro_display_info');
        foreach ($display_types as $name => $display_info) {
          // Provide defaults.
          $display_info += array(
            'settings' => array(),
          );
          $info['display_types'][$name] = $display_info;
          $info['display_types'][$name]['module'] = $module;
        }
      }
      drupal_alter('micro_display_info', $info['display_types']);

      variable_set("micro_display_types", $info);
    }
  }

  return $info;
}

/**
 * Returns information about micro input types from hook_micro_input_info().
 *
 * @param $input_type
 *   (optional) A input type name. If ommitted, all input types will be
 *   returned.
 *
 * @return
 *   Either a single input type description, as provided by
 *   hook_micro_input_info(), or an array of all existing input types, keyed
 *   by input type name.
 */
function micro_input_types($input_type = NULL) {
  $info = _micro_displays_build();
  $input_types = $info['input_types'];
  if ($input_type) {
    if (isset($input_types[$input_type])) {
      return $input_types[$input_type];
    }
  }
  else {
    return $input_types;
  }
}

/**
 * Returns information about micro displays from hook_micro_display_info().
 *
 * @param $display_type
 *   (optional) A display type name. If ommitted, all display types will be
 *   returned.
 *
 * @return
 *   Either a single display type description, as provided by
 *   hook_micro_display_info(), or an array of all existing display types,
 *   keyed by display type name.
 */
function micro_display_types($display_type = NULL) {
  $info = _micro_displays_build();
  $display_types = $info['display_types'];
  if ($display_type) {
    if (isset($display_types[$display_type])) {
      return $display_types[$display_type];
    }
  }
  else {
    return $display_types;
  }
}

/**
 * Builds and returns the list of available micro types.
 *
 * The list of types is built by invoking hook_micro_info() on all modules and
 * comparing this information with the micro types in the {micro_type} table.
 * These two information sources are not synchronized during module installation
 * until micro_types_rebuild() is called.
 *
 * @param $rebuild
 *  TRUE to rebuild micro types. Equivalent to calling micro_types_rebuild().
 * @return
 *   Associative array with two components:
 *   - names: Associative array of the names of micro types, keyed by the type.
 *   - types: Associative array of micro type objects, keyed by the type.
 *   Both of these arrays will include new types that have been defined by
 *   hook_micro_info() implementations but not yet saved in the {micro_type}
 *   table. These are indicated in the type object by $type->is_new being set
 *   to the value 1. These arrays will also include obsolete types: types that
 *   were previously defined by modules that have now been disabled, or for
 *   whatever reason are no longer being defined in hook_micro_info()
 *   implementations, but are still in the database. These are indicated in the
 *   type object by $type->disabled being set to TRUE.
 */
function _micro_types_build($rebuild = FALSE) {
  if (!$rebuild) {
    $_micro_types = &drupal_static(__FUNCTION__);
    if (is_object($_micro_types)) {
      return $_micro_types;
    }
  }

  $_micro_types = (object)array('types' => array(), 'names' => array(), 'ids' => array());

  foreach (module_implements('micro_info') as $module) {
    $info_array = module_invoke($module, 'micro_info');
    foreach ($info_array as $type => $info) {
      $info['type'] = $type;
      $_micro_types->types[$type] = micro_type_set_defaults($info);
      $_micro_types->types[$type]->module = $module;
      $_micro_types->names[$type] = $info['name'];
    }
  }
  $query = db_select('micro_type', 'mt')
    ->addTag('micro_type_access')
    ->fields('mt')
    ->orderBy('mt.machine_name', 'ASC');
  if (!$rebuild) {
    $query->condition('disabled', 0);
  }
  foreach ($query->execute() as $type_object) {
    $type_db = $type_object->machine_name;
    // Original disabled value.
    $disabled = $type_object->disabled;
    // Check for micro types from disabled modules and mark their types for removal.
    // Types defined by the micro module in the database (rather than by a separate
    // module using hook_micro_info) have a base value of 'micro_content'.
    if (isset($type_object->base) && $type_object->base != 'micro_content' && empty($info_array[$type_db])) {
      $type_object->disabled = TRUE;
    }
    if (isset($info_array[$type_db])) {
      $type_object->disabled = FALSE;
    }
    if (!isset($_micro_types->types[$type_db])) {
      $_micro_types->types[$type_db] = $type_object;
      $_micro_types->names[$type_db] = $type_object->name;
      $_micro_types->types[$type_db]->bundles = unserialize($_micro_types->types[$type_db]->bundles);
      $_micro_types->types[$type_db]->data = unserialize($_micro_types->types[$type_db]->data);
    }
    $_micro_types->types[$type_db]->disabled = $type_object->disabled;
    $_micro_types->types[$type_db]->disabled_changed = $disabled != $type_object->disabled;
  }

  if ($rebuild) {
    foreach ($_micro_types->types as $type => $type_object) {
      if (!empty($type_object->is_new) || !empty($type_object->disabled_changed)) {
        micro_type_save($type_object);
      }
    }
  }

  foreach ($_micro_types->types as $type) {
    $_micro_types->ids[$type->mtid] = $type;
  }

  asort($_micro_types->names);
  return $_micro_types;
}

/**
 * Gets an array of all micro types, keyed by the type name.
 *
 * @param $type
 *   If set, the type with the given name is returned.
 * @return microType[]
 *   Depending whether $type isset, an array of micro types or a single one.
 */
function micro_get_types($type = NULL) {
  // @todo: fix fugly variable names.
  $types = entity_load('micro_type', isset($type) ? array($type) : FALSE);
  if (isset($type)) {
    return isset($types[$type]) ? $types[$type] : FALSE;
  }
  return $types;
}

function micro_types_from_entity($entity, $bundle) {
  $types = array();
  foreach (micro_type_get_types() as $micro_type) {
    if($entity == $micro_type->entity && in_array($bundle, $micro_type->bundles)) {
      $types[$micro_type->machine_name] = $micro_type;
    }
  }
  return $types;
}

/**
 * Implements hook_micro_display_info()
 */
function micro_micro_display_info() {
  return array(
    /*
     *'simple_page_display' => array(
     *  'label' => t('Simple page'),
     *  'micro_types' => array(),
     *  'theme' => 'micro_simple_page_display',
     *),
     */
    'wrapper' => array(
      'label' => t('Inline'),
      'micro_types' => array(),
      'theme' => 'micro_wrapper',
    ),
    'test_display' => array(
      'label' => t('Test'),
      'micro_types' => array('status' => 'status'),
      'theme' => 'micro_test_display',
    ),
  );
}

/**
 * Implements hook_micro_input_info()
 */
function micro_micro_input_info() {
  return array(
    /*
     *'simple_page_input' => array(
     *  'label' => t('Simple page'),
     *  'micro_types' => array(),
     *  'theme' => 'micro_simple_page_input',
     *),
     */
    'linked_page_input' => array(
      'label' => t('Linked page'),
      'micro_types' => array(),
      'theme' => 'micro_linked_page_input',
    ),
    'ajax_form_input' => array(
      'label' => t('Ajax form'),
      'micro_types' => array(),
      'theme' => 'micro_ajax_form_input',
    ),
    'inline_form_input' => array(
      'label' => t('Inline form'),
      'micro_types' => array(),
      'theme' => 'micro_inline_form_input',
    ),
    'test_form_input' => array(
      'label' => t('test input'),
      'micro_types' => array('status' => 'status'),
      'required' => TRUE,
      'theme' => 'micro_test_form_input',
    ),
  );
}

function micro_get_display($entity, $id, $view_mode = null) {
  $output = array();
  $input = isset($view_mode) ? 'input_' . $view_mode : 'input';
  $display = isset($view_mode) ? 'display_' . $view_mode : 'display';
  $input_types = micro_input_types();
  $display_types = micro_display_types();
  include_once(drupal_get_path('module', 'micro') . '/micro.pages.inc');
  foreach (micro_types_from_entity($entity->content['#entity_type'], $entity->content['#bundle']) as $micro_type) {
    // Load and prepare the micro items
    $micro_items = micro_view_multiple(micro_load_from_type($micro_type->mtid, $id));
    $form = micro_add($micro_type->machine_name, $id);
    dsm($micro_type->data['format'][$input]);
    if ($input_types[$micro_type->data['format'][$input]]['theme'] != 'none') {
      $output[$micro_type->machine_name]['input'] = array(
        '#form' => $form,
        '#theme' => $input_types[$micro_type->data['format'][$input]]['theme'],
      );
    }
    if ($display_types[$micro_type->data['format'][$display]]['theme'] != 'none') {
      $output[$micro_type->machine_name]['display'] = array(
        '#entity' => $entity,
        '#items' => reset($micro_items),
        '#bundle' => $micro_type->machine_name,
        '#theme' => $display_types[$micro_type->data['format'][$display]]['theme'],
      );
    }
  }
  return $output;
}

/**
 * Menu callback; view a single micro.
 */
function micro_page_view($micro) {
  // If there is a menu link to this micro, the link becomes the last part
  // of the active trail, and the link name becomes the page title.
  // Thus, we must explicitly set the page title to be the micro title.
  $type = micro_type_get_type($micro);
  // If there's no view page, go to parent's uri
  if (!$type->data['view_page']) {
    drupal_goto($type->entity . '/' . $micro->eid);
  }
  drupal_set_title($micro->mid);
  $uri = entity_uri('micro', $micro);
  // Set the micro path as the canonical URL to prevent duplicate content.
  drupal_add_html_head_link(array('rel' => 'canonical', 'href' => url($uri['path'], $uri['options'])), TRUE);
  // Set the non-aliased path as a default shortlink.
  drupal_add_html_head_link(array('rel' => 'shortlink', 'href' => url($uri['path'], array_merge($uri['options'], array('alias' => TRUE)))), TRUE);
  return micro_view_multiple(array($micro->mid => $micro));
}

/**
 * Construct a drupal_render() style array from an array of loaded micro items.
 *
 * @param $micro_items
 *   An array of micro items as returned by micro_load_multiple().
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param $weight
 *   An integer representing the weight of the first micro in the list.
 *
 * @return
 *   An array in the format expected by drupal_render().
 */
function micro_view_multiple($micro_items, $view_mode = 'full', $weight = 0) {
  field_attach_prepare_view('micro', $micro_items, $view_mode);
  entity_prepare_view('micro', $micro_items);
  $build = array();
  foreach ($micro_items as $micro) {
    $build['micro_items'][$micro->mid] = micro_view($micro, $view_mode);
    $build['micro_items'][$micro->mid]['#weight'] = $weight;
    $weight++;
  }
  $build['micro_items']['#sorted'] = TRUE;
  return $build;
}


//======
//FORMS.
//======

/**
 * Implements hook_form().
 */
function micro_content_form($micro, $form_state) {
  // It is impossible to define a content type without implementing hook_form()
  // @todo: remove this requirement.
  $form = array();
  $type = micro_type_get_type($micro);
  return $form;
}


//================
//THEME FUNCTIONS.
//================

/**
 * Process variables for micro.tpl.php
 *
 * Most themes utilize their own copy of micro.tpl.php. The default is located
 * inside "modules/micro/micro.tpl.php". Look in there for the full list of
 * variables.
 *
 * The $variables array contains the following arguments:
 * - $micro
 * - $view_mode
 * - $page
 *
 * @see micro.tpl.php
 */
function template_preprocess_micro(&$variables) {
  $variables['micro'] = $variables['elements']['#micro'];
  $micro = $variables['micro'];
  $variables['micro_type'] = micro_type_get_type($micro);
  $micro_type = $variables['micro_type'];
  $variables['view_mode'] = $variables['elements']['#view_mode'];
  $variables['entity'] = $variables['elements']['#entity'];
  $variables['date']      = format_date($micro->created);
  $variables['name']      = theme('username', array('account' => $micro));
  $uri = entity_uri('micro', $micro);
  $variables['micro_url']  = url($uri['path'], $uri['options']);
  $variables['title']      = $micro->mid;
  $variables['page']       = $variables['view_mode'] == 'full' && micro_is_page($micro);

  // Flatten the micro object's member fields.
  $variables = array_merge((array) $micro, $variables);

  // Helpful $content variable for templates.
  foreach (element_children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }

  // Make the field variables available with the appropriate language.
  field_attach_preprocess('micro', $micro, $variables['content'], $variables);

  //TODO
  // Display post information only on certain micro types.
  if (variable_get('micro_submitted_' . $micro_type->machine_name, TRUE)) {
    $variables['display_submitted'] = TRUE;
    $variables['user_picture'] = theme_get_setting('toggle_micro_user_picture') ? theme('user_picture', array('account' => $micro)) : '';
  }
  else {
    $variables['display_submitted'] = FALSE;
    $variables['user_picture'] = '';
  }

  // Gather micro classes.
  $variables['classes_array'][] = drupal_html_class('micro-' . $micro_type->machine_name);

  // Clean up name so there are no underscores.
  $variables['theme_hook_suggestions'][] = 'micro__' . $micro_type->machine_name;
  $variables['theme_hook_suggestions'][] = 'micro__' . $micro->mid;
}

/**
 * Process variables for micro-wrapper.tpl.php.
 *
 * @see micro-wrapper.tpl.php
 * @see theme_micro_wrapper()
 */
function template_preprocess_micro_wrapper(&$variables) {
  // Provide contextual information.
  $bundle = $variables['elements']['#bundle'];
  $variables['entity'] = $variables['elements']['#entity'];
  $variables['bundle'] = $bundle;
  /*
   *$variables['display_mode'] = variable_get('micro_default_mode_' . $variables['node']->type, micro_MODE_THREADED);
   */
  // Clean up name so there are no underscores.
  $variables['theme_hook_suggestions'][] = 'micro_wrapper__' . $bundle;
}
/*
 *function theme_micro_wrapper($variables) {
 *}
 */
function theme_micro_inline_form_input($form) {
  return drupal_render($form['form']);
}
    /*
     *'micro_wrapper' => array(
     *  'variables' => array('a' => null, 'b' => null, 'c' => null),
     *),
     *'micro_linked_page_input' => array(
     *  'variables' => array('a' => null, 'b' => null, 'c' => null),
     *),
     *'micro_ajax_form_input' => array(
     *  'variables' => array('a' => null, 'b' => null, 'c' => null),
     *),
     *'micro_inline_form_input' => array(
     *  'variables' => array('a' => null, 'b' => null, 'c' => null),
     *),
     */

//==================
//VIEWS INTEGRATION.
//==================

/**
 * Implements hook_views_api().
 * TODO
 */
function micro_views_api() {
  return array(
    'api' => 2.0,
    'path' => drupal_get_path('module', 'micro') . '/includes',
  );
}


//===================
//ACTION INTEGRATION.
//===================

/**
 * Implements hook_action_info().
 * TODO - micro_delete_action
 * TODO - micro_delete_from_user_action
 * TODO - micro_change_eid_action
 * TODO - micro_change_user_action
 */
function micro_action_info() {
  return array(
    'micro_save_action' => array(
      'type' => 'micro',
      'label' => t('Save content'),
      'configurable' => FALSE,
      'triggers' => array('comment_insert', 'comment_update', 'comment_delete'),
    ),
  );
}

/**
 * Saves a micro.
 *
 * @ingroup actions
 */
function micro_save_action($micro) {
  micro_save($micro);
  watchdog('action', 'Saved @type %id', array('@type' => micro_type_get_name($micro), '%title' => $micro->mid));
}


/**
 * Implements hook_user_view().
 */
/*
 *function micro_user_view($account, $view_mode) {
 *  $micros = micro_get_micros('user');
 *  $micro_items = array();
 *  foreach ($micros as $micro) {
 *    if (!$micro->access($account->uid)) {
 *      // User has no permission to use this micro.
 *      continue;
 *    }
 *    if (!$micro->uses_hook_link(array())){
 *      // micro not set to appear on profile.
 *      continue;
 *    }
 *    $micro_items[$micro->name] = array(
 *      '#type' => 'user_profile_item',
 *      '#title' => $micro->get_title($account->uid),
 *      '#value' => $micro->theme($micro->is_microged($account->uid) ? 'unmicro' : 'micro', $account->uid),
 *      '#attributes' => array('class' => array('micro-profile-' . $micro->name)),
 *    );
 *  }
 *  if (!empty($micro_items)) {
 *    $account->content['micros'] = $micro_items;
 *    $account->content['micros'] += array(
 *      '#type' => 'user_profile_category',
 *      '#title' => t('Actions'),
 *      '#attributes' => array('class' => array('micro-profile')),
 *    );
 *  }
 *}
 */
/**
 * Implements hook_user_cancel().
 */
/*
 *function micro_user_cancel($edit, $account, $method) {
 *  // Remove micros by this user.
 *  $query = db_select('micro_content', 'fc');
 *  $query->leftJoin('micro_counts', 'c', 'fc.content_id = c.content_id AND fc.content_type = c.content_type');
 *  $result = $query
 *    ->fields('fc', array('fid', 'content_id'))
 *    ->fields('c', array('count'))
 *    ->condition('fc.uid', $account->uid)
 *    ->execute();
 *
 *  foreach ($result as $micro_data) {
 *    $micro_data->count--;
 *    db_update('micro_counts')
 *      ->fields(array(
 *        'count' => $micro_data->count,
 *      ))
 *      ->condition('fid', $micro_data->fid)
 *      ->condition('content_id', $micro_data->content_id)
 *      ->execute();
 *  }
 *  db_delete('micro_content')
 *    ->condition('uid', $account->uid)
 *    ->execute();
 *}
 */

//TODO - Blocks
//TODO - is_new
//TODO - micro.js + micro_types.js
//TODO - hook_uninstall, hook_disable, micro_enable
//TODO - THEME FUNCTIONS
//TODO - micro_load_by_user vs micro_load_from_type (need for cache?)
//TODO - nojs for ajax form
//TODO - all conditions for 'site'
//TODO - form validation
//TODO - column 'module' vs 'build'
//TODO - integrate options (delete confirmation and expiration time)
//TODO - micro_get_types vs micro_type_get_types
//TODO - admin_menu: fix 'list micro types' = list, submenus
//TODO - change default view_mode from full to short
//TODO - reset() in micro_get_display, or remove 'micro_items' from micro_view_multiple
//TODO - contextual links? + links?
//TODO - explore node->extra (rss/search)
//TODO - repost functionality
//TODO - micro table's 'type' should be mtid = mtid (id) from micro_type, and type = machine_name

//TODO - required display/input from another module (for already existing options) - should go in hook_micro_info
//TODO - Check if Devel generate integration is needed
//TODO - Check if Rules integration is needed
//TODO - Search integration
//TODO - extra modules: micro_access, micro_url

