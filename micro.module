<?php
// $Id$ micro.module, v 1.0 2010/12/01 04:20:00 blup Exp $

/**
 * @file
 * Micro entity that attaches to other entities (or site)
 */

/**
 * Modules should return this value from hook_micro_access() to allow access to a micro.
 */
define('MICRO_ACCESS_ALLOW', 'allow');

/**
 * Modules should return this value from hook_micro_access() to deny access to a micro.
 */
define('MICRO_ACCESS_DENY', 'deny');

/**
 * Modules should return this value from hook_micro_access() to not affect micro access.
 */
define('MICRO_ACCESS_IGNORE', NULL);

/**
 * Defining the admin path.
 */
define('MICRO_ADMIN_PATH', 'admin/structure/micro');


//=============
//DRUPAL HOOKS.
//=============

/**
 * Implements hook_init().
 * TODO - token and actions files
 */
function micro_init() {
  $path = drupal_get_path('module', 'micro');
  //include_once $path .'/includes/micro.token.inc';
  if (module_exists('trigger')) {
    //include_once $path .'/includes/micro.actions.inc';
  }
}

/**
 * Implementation of hook_cron().
 * TODO
 */
function micro_cron() {
/*
 *  $expiration = variable_get('micro_expire', 0);
 *
 *  // Check if expiration is turned on
 *  if ($expiration > 0) {
 *    // Fetch shouts that have passed the expiration date
 *    $micro_items = db_query("SELECT * FROM {micro} WHERE created < %d", time() - (60 * 60 * 24 * $expiration));
 *    while ($micro = db_fetch_object($micro_items)) {
 *      // Delete the shout
 *      micro_delete_shout($micro);
 *    }
 *  }
 */
}

/**
 * Implementation of hook_help().
 */
function micro_help($path, $arg) {
  if ($path == 'admin/help#micro') {
    return t('Provides a new micro entity that can be attached to other entities.');
  }
}

/**
 * Implements hook_menu().
 */
function micro_menu() {
  $items['admin/content/micro'] = array(
    'title' => 'Micro',
    'description' => 'List and edit micro items.',
    'page callback' => 'micro_admin',
    'access arguments' => array('administer micro'),
    'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
    'file' => 'micro.admin.inc',
  );
  // Tabs begin here.
  /*
   *$items['admin/content/micro/new'] = array(
   *  'title' => 'Published comments',
   *  'type' => MENU_DEFAULT_LOCAL_TASK,
   *  'weight' => -10,
   *);
   *$items['admin/content/micro/approval'] = array(
   *  'title' => 'Unapproved comments',
   *  'title callback' => 'comment_count_unpublished',
   *  'page arguments' => array('approval'),
   *  'access arguments' => array('administer comments'),
   *  'type' => MENU_LOCAL_TASK,
   *);
   */
  $items['admin/structure/micro'] = array(
    'title' => 'Micro types',
    'description' => 'Manage content types, including default status, front page promotion, comment settings, etc.',
    'page callback' => 'micro_overview_types',
    'access arguments' => array('administer content types'),
    'file' => 'micro.admin.inc',
  );
  $items['admin/structure/micro/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/structure/micro/add'] = array(
    'title' => 'Add micro type',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('micro_type_form'),
    'access arguments' => array('administer micro types'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'micro.admin.inc',
  );
  $items['admin/structure/micro/manage/%micro_type'] = array(
    'title' => 'Edit micro type',
    'title callback' => 'micro_type_page_title',
    'title arguments' => array(4),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('micro_type_form', 4),
    'access arguments' => array('administer micro types'),
    'file' => 'micro.admin.inc',
  );
  $items['admin/structure/micro/manage/%micro_type/edit'] = array(
    'title' => 'Edit micro type',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/structure/micro/manage/%micro_type/delete'] = array(
    'title' => 'Delete micro type',
    'page arguments' => array('micro_type_delete_confirm', 4),
    'access arguments' => array('administer micro types'),
    'file' => 'micro.admin.inc',
  );

  $items['micro'] = array(
    'page callback' => 'micro_page_default',
    'access arguments' => array('access micro items'),
    // Required to make 'micro/add' appear on the top-level of 'navigation' menu.
    'menu_name' => '',
    'type' => MENU_CALLBACK,
  );
  $items['micro/add'] = array(
    'title' => 'Add micro item',
    'page callback' => 'micro_add_page',
    'access callback' => '_micro_add_access',
    'menu_name' => 'navigation',
    'theme callback' => '_micro_custom_theme',
    'file' => 'micro.pages.inc',
  );
  /*
   *$items['micro-rss.xml'] = array(
   *  'title' => 'RSS feed',
   *  'page callback' => 'micro_feed',
   *  'access arguments' => array('access content'),
   *  'type' => MENU_CALLBACK,
   *);
   */
  drupal_static_reset('_micro_types_build');
  foreach (micro_type_get_types() as $type) {
    $type_url_str = str_replace('_', '-', $type->machine_name);
    $items['micro/add/' . $type_url_str] = array(
      'title' => $type->name,
      'title callback' => 'check_plain',
      'page callback' => 'micro_add',
      'page arguments' => array($type->machine_name, 3),
      'access callback' => 'micro_access',
      'access arguments' => array('create', $type->machine_name),
      'description' => $type->description,
      'file' => 'micro.pages.inc',
    );
  }
  $items['micro/%micro'] = array(
    'title callback' => 'micro_page_title',
    'title arguments' => array(1),
    // The page callback also invokes drupal_set_title() in case
    // the menu router's title is overridden by a menu link.
    'page callback' => 'micro_page_view',
    'page arguments' => array(1),
    'access callback' => 'micro_access',
    'access arguments' => array('view', 1),
  );
  $items['micro/%micro/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['micro/%micro/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'micro_page_edit',
    'page arguments' => array(1),
    'access callback' => 'micro_access',
    'access arguments' => array('update', 1),
    'theme callback' => '_micro_custom_theme',
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'micro.pages.inc',
  );
  $items['micro/%micro/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('micro_delete_confirm', 1),
    'access callback' => 'micro_access',
    'access arguments' => array('delete', 1),
    'theme callback' => '_micro_custom_theme',
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'micro.pages.inc',
  );

  $items['micro/ajax/add'] = array(
    'page callback' => 'micro_ajax_add',
    'type' => MENU_CALLBACK,
  );
  $items['micro/ajax/add/%/%micro_type/%/%'] = array(
    'page callback' => 'micro_ajax_add',
    'page arguments' => array(3, 4, 5, 6),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  /*
   *$items['micro/ajax/add/%/%micro_type/%'] = array(
   *  'page callback' => 'micro_ajax_add',
   *  'page arguments' => array(3,4,5),
   *  'access callback' => 'micro_access',
   *  'access arguments' => array('access content'),
   *  'type' => MENU_CALLBACK,
   *);
   */
  /*
   *$items['micro/ajax/add/ajax/%micro_type/%'] = array(
   *  'page callback' => 'micro_ajax_add',
   *  'page arguments' => array(TRUE, 4, 5),
   *  'access callback' => 'micro_access',
   *  'access arguments' => array('access content'),
   *  'type' => MENU_CALLBACK,
   *);
   */


  return $items;
}

/**
 * Implements hook_theme().
 */
function micro_theme() {
  return array(
    'micro' => array(
      'template' => 'micro',
      'render element' => 'elements',
    ),
    'micro_admin_type' => array(
      'variables' => array('name' => NULL, 'type' => NULL),
    ),
    'micro_admin_overview' => array(
      'variables' => array('name' => NULL, 'type' => NULL),
    ),
    'micro_wrapper' => array(
      'template' => 'micro-wrapper',
      'render element' => 'elements',
    ),
    'micro_linked_page_input' => array(
      'render element' => 'elements',
      /*
       *'variables' => array('elements' => null),
       */
    ),
    'micro_ajax_form_input' => array(
      'render element' => 'elements',
      /*
       *'variables' => array('elements' => null),
       */
    ),
    'micro_inline_form_input' => array(
      'render element' => 'elements',
      /*
       *'variables' => array('elements' => null),
       */
    ),
  );
}
/**
 * Implements hook_permission().
 */
function micro_permission() {
  $permissions = array(
    'bypass micro access' =>  array(
      'title' => t('Bypass micro access'),
      'description' => t('Bypass all access permissions for micro items.'),
    ),
    'access micro items' =>  array(
      'title' => t('Access micro items'),
      'description' => t('Access micro items.'),
    ),
    'administer micro types' =>  array(
      'title' => t('Administer micro types'),
      'description' => t('Create and delete fields for micro types.'),
    ),
    'administer micro items' =>  array(
      'title' => t('Administer micro items'),
      'description' => t('Edit and view all micro items.'),
    ),
  );
  // Generate per micro type permissions.
  foreach (micro_type_get_types() as $type) {
    $type_name = check_plain($type->machine_name);
    $permissions += array(
      "create $type_name micro items" => array(
        'title' => t('%type_name: Create new items', array('%type_name' => $type->name)),
      ),
      "edit own $type_name micro items" => array(
        'title' => t('%type_name: Edit own items', array('%type_name' => $type->name)),
      ),
      "edit attached $type_name micro items" => array(
        'title' => t('%type_name: Edit %type_name items attached to own content', array('%type_name' => $type->name)),
      ),
      "edit any $type_name micro items" => array(
        'title' => t('%type_name: Edit any items', array('%type_name' => $type->name)),
      ),
      "delete own $type_name micro items" => array(
        'title' => t('%type_name: Delete own items', array('%type_name' => $type->name)),
      ),
      "delete attached $type_name micro items" => array(
        'title' => t('%type_name: Delete %type_name items attached to own content', array('%type_name' => $type->name)),
      ),
      "delete any $type_name micro items" => array(
        'title' => t('%type_name: Delete any items', array('%type_name' => $type->name)),
      ),
    );
  }
  return $permissions;
}

/**
 * Implements hook_node_view().
 */
function micro_node_view($node, $view_mode) {
  _micro_entity_view($node, $node->nid, $view_mode);
}

/**
 * Implements hook_comment_view()
 */
function micro_comment_view($comment, $view_mode, $langcode) {
  _micro_entity_view($comment, $comment->cid, $view_mode);
}

/**
 * Implements hook_user_view()
 */
function micro_user_view($account, $view_mode, $langcode) {
  _micro_entity_view($account, $account->uid, $view_mode);
}

/**
 * Implements hook_node_delete().
 */
function micro_node_delete($node) {
  _micro_entity_delete('node', $node->type, $node->nid);
}

/**
 * Implements hook_comment_delete()
 */
function micro_comment_delete($comment) {
  _micro_entity_delete('comment', $comment->type, $node->cid);
}

/**
 * Implements hook_user_cancel().
 */
function micro_user_cancel(&$edit, $account, $method) {
  // Delete all micro items of the user in any case.
  foreach (micro_load_by_user($account) as $micro) {
    micro_delete($micro);
  }
}
/**
 * Implements hook_forms().
 * All micro forms share the same form handler.
 */
function micro_forms() {
  $forms = array();
  if ($types = micro_type_get_types()) {
    foreach (array_keys($types) as $type) {
      $forms[$type . '_micro_form']['callback'] = 'micro_form';
    }
  }
  return $forms;
}

/**
 * Implements hook_entity_info()
 * TODO - check
 */
function micro_entity_info() {
  $return = array(
    'micro' => array(
      'label' => t('Micro'),
      'entity class' => 'Micro',
      'controller class' => 'MicroController',
      'base table' => 'micro',
      'uri callback' => 'micro_uri',
      'fieldable' => TRUE,
      'view modes' => array(
        'small' => array(
          'label' => t('Small view'),
        ),
        'full' => array(
          'label' => t('Page view'),
        ),
      ),
      'entity keys' => array(
        'id' => 'mid',
        'bundle' => 'type',
        'label' => 'mid',
      ),
      'bundles' => array(),
      'bundle keys' => array(
        'bundle' => 'machine_name',
      ),
    ),
  );

  $return['micro_type'] = array(
    'label' => t('Micro type'),
    'entity class' => 'MicroType',
    'controller class' => 'EntityAPIController',
    'base table' => 'micro_type',
    'fieldable' => FALSE,
    'bundle of' => 'micro',
    'exportable' => TRUE,
    'entity keys' => array(
      'id' => 'mtid',
      'name' => 'machine_name',
      'label' => 'name',
    ),
  );


  // Bundles must provide a human readable name so we can create help and error
  // messages, and the path to attach Field admin pages to.
  /*
   *foreach (micro_type_get_names() as $type => $name) {
   *  $return['micro']['bundles'][$type] = array(
   *    'label' => $name,
   *    'admin' => array(
   *      'path' => 'admin/structure/micro/manage/%micro_type',
   *      'real path' => 'admin/structure/micro/manage/' . str_replace('_', '-', $type),
   *      'bundle argument' => 4,
   *      'access arguments' => array('administer micro types'),
   *    ),
   *  );
   *}
   */

  return $return;
}

/**
 * Implements hook_entity_info_alter().
 *
 * Use this hook to specify profile bundles to avoid a recursion, as loading
 * the profile types needs the entity info too.
 */
function micro_entity_info_alter(&$entity_info) {
  foreach (micro_type_get_types(TRUE) as $type => $info) {
    $entity_info['micro']['bundles'][$type] = array(
      'label' => $info->name,
      'admin' => array(
        'path' => 'admin/structure/micro/manage/%micro_type',
        'real path' => 'admin/structure/micro/manage/' . $type,
        'bundle argument' => 4,
        'access arguments' => array('administer micro'),
      ),
    );
  }
}
/**
 * Controller class for micro items.
 *
 * This extends the EntityAPIController class.
 */
class MicroController extends EntityAPIController {

  protected function buildQuery($ids, $conditions = array(), $revision_id = FALSE) {
    $query = parent::buildQuery($ids, $conditions, $revision_id);
    // Add the machine name field from the {micro_type} table.
    $query->innerJoin('micro_type', 'mt', 'base.mtid = mt.mtid');
    $query->addField('mt', 'machine_name', 'type');
    return $query;
  }
}

/**
 * The class used for micro entities.
 */
class Micro extends EntityDBExtendable {

  public function __construct($values = array()) {
    parent::__construct($values, 'micro');
  }
}

/**
 * Use a separate class for micro types so we can specify some defaults
 * modules may alter.
 * TODO - change variables
 */

class MicroType extends EntityDBExtendable {


  /**
   * Whether the micro type appears in the user categories.
   */

  /*
   *public $userCategory = TRUE;
   */


  /**
   * Whether the micro is displayed on the user account page.
   */

  /*
   *public $userView = TRUE;
   */


  /*
   *public $type;
   */
  public $name;
  public $weight = 0;

  public function __construct($values = array()) {
    parent::__construct($values, 'micro_type');
  }


  /**
   * Returns whether the micro type is locked, thus may not be deleted or renamed.
   *
   * Micro types provided in code are automatically treated as locked, as well
   * as any fixed micro type.
   */

  public function isLocked() {
    return isset($this->disabled) && (($this->disabled & ENTITY_IN_CODE) || ($this->disabled & ENTITY_FIXED));
  }
}


//==========
//MICRO API.
//==========

/**
 * Determine whether the current user may perform the given operation on the
 * specified micro.
 *
 * @param $op
 *   The operation to be performed on the micro. Possible values are:
 *   - "view"
 *   - "update"
 *   - "delete"
 *   - "create"
 * @param $micro
 *   The micro object on which the operation is to be performed, or micro type
 *   for "create" operation.
 * @param $account
 *   Optional, a user object representing the user for whom the operation is to
 *   be performed. Determines access for a user other than the current user.
 * @return
 *   TRUE if the operation may be performed, FALSE otherwise.
 */
function micro_access($op, $micro, $account = NULL) {
  global $user;

  $rights = &drupal_static(__FUNCTION__, array());

  if (!$micro || !in_array($op, array('view', 'update', 'delete', 'create'), TRUE)) {
    // If there was no micro to check against, or the $op was not one of the
    // supported ones, we return access denied.
    return FALSE;
  }
  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $user;
  }

dsm($account);
  // $micro may be either an object or a micro type. Since micro types cannot be
  // an integer, use either mid or type as the static cache id.

  $cid = is_object($micro) ? $micro->mid : $micro;

  // If we've already checked access for this micro, user and op, return from
  // cache.
/*
 *  if (isset($rights[$account->uid][$cid][$op])) {
 *    return $rights[$account->uid][$cid][$op];
 *  }
 *
 *  if (user_access('bypass micro access', $account)) {
 *    $rights[$account->uid][$cid][$op] = TRUE;
 *    return TRUE;
 *  }
 */
  if (!user_access('access micro items', $account)) {
    $rights[$account->uid][$cid][$op] = FALSE;
    return FALSE;
  }

  // We grant access to the micro if both of the following conditions are met:
  // - No modules say to deny access.
  // - At least one module says to grant access.
  // If no module specified either allow or deny, we fall back to the defaults.
  $access = module_invoke_all('micro_access', $micro, $op, $account);
  if (in_array(MICRO_ACCESS_DENY, $access, TRUE)) {
    $rights[$account->uid][$cid][$op] = FALSE;
    return FALSE;
  }
  elseif (in_array(MICRO_ACCESS_ALLOW, $access, TRUE)) {
    $rights[$account->uid][$cid][$op] = TRUE;
    dsm('1');
    return TRUE;
  }

  return FALSE;
}

/**
 * Create a new micro object.
 */
function micro_create(array $values) {
  return new Micro($values);
}

/**
 * Saves a micro to the database.
 *
 * @param $micro
 *   The micro object.
 */
function micro_save(Micro $micro) {
  if (!isset($micro->type)) {
    $micro_type = micro_type_get_type($micro);
    $micro->type = $micro_type->machine_name;
  }
  return $micro->save();
}

/**
 * Load a micro object from the database.
 *
 * @param $mid
 *   The micro ID.
 * @param $vid
 *   The revision ID.
 * @param $reset
 *   Whether to reset the micro_load_multiple cache.
 *
 * @return
 *   A fully-populated micro object.
 */
function micro_load($mid = NULL, $reset = FALSE) {
  $mids = (isset($mid) ? array($mid) : array());
  $micro = micro_load_multiple($mids, $reset);
  return $micro ? reset($micro) : FALSE;
}

/**
 * Load micro entities from the database.
 *
 * This function should be used whenever you need to load more than one micro
 * from the database. Micro items are loaded into memory and will not require
 * database access if loaded again during the same page request.
 *
 * @see entity_load()
 *
 * @param $mids
 *   An array of micro IDs.
 * @param $conditions
 *   An array of conditions on the {micro} table in the form 'field' => $value.
 * @param $reset
 *   Whether to reset the internal micro_load cache.
 *
 * @return
 *   An array of micro objects indexed by mid.
 */
function micro_load_multiple($mids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('micro', $mids, $conditions, $reset);
}
/**
 * Fetch micro items by account.
 *
 * @param $account
 *   The user account to load micro items for, or its uid.
 * @param $type
 *   To load a single micro, pass the type of the micro to load.
 * @return
 *   Either a single micro or an array of micro items keyed by micro type.
 *
 * @see micro_load_multiple()
 */
function micro_load_by_user($account, $type = NULL) {
  // Use a separate query to determine all micro ids per user and cache them.
  // That way we can look up micro items by id and benefit from the static cache
  // of the entity loader.
  $cache = drupal_static(__FUNCTION__, array());
  $uid = is_object($account) ? $account->uid : $account;

  if (!isset($cache[$uid])) {
    if (empty($type)) {
      $micro_items = micro_load_multiple(array(), array('uid' => $uid));
      // Cache ids for further lookups.
      $cache[$uid] = array();
      foreach ($micro_items as $mid => $micro) {
        $cache[$uid][$micro->mtid] = $mid;
      }
      return array_combine(array_keys($cache[$uid]), $micro_items);
    }
    $cache[$uid] = db_select('micro', 'm')
      ->fields('m', array('mtid', 'mid'))
      ->condition('uid', $uid)
      ->execute()
      ->fetchAllKeyed();
  }
  if (isset($type)) {
    return isset($cache[$uid][$type]) ? micro_load($cache[$uid][$type]) : FALSE;
  }
  // Return an array containing micro items keyed by micro type.
  return $cache[$uid] ? array_combine(array_keys($cache[$uid]), micro_load_multiple($cache[$uid])) : $cache[$uid];
}

/**
 * Deletes a micro.
 */
function micro_delete(Micro $micro) {
  $micro->delete();
}

/**
 * Delete multiple micro items.
 *
 * @param $mids
 *   An array of micro IDs.
 */
function micro_delete_multiple(array $mids) {
  entity_get_controller('micro')->delete($mids);
}

/**
 * Determine whether a micro hook exists.
 *
 * @param $micro
 *   A micro object or a string containing the micro type.
 * @param $hook
 *   A string containing the name of the hook.
 * @return
 *   TRUE if the $hook exists in the micro type of $micro.
 */
function micro_hook($micro, $hook) {
  $base = micro_type_get_module($micro) . '_content';
  return module_hook($base, $hook);
}

/**
 * Invoke a micro hook.
 *
 * @param $micro
 *   A micro object or a string containing the micro type.
 * @param $hook
 *   A string containing the name of the hook.
 * @param $a2, $a3, $a4
 *   Arguments to pass on to the hook, after the $micro argument.
 * @return
 *   The returned value of the invoked hook.
 */
function micro_invoke($micro, $hook, $a2 = NULL, $a3 = NULL, $a4 = NULL) {
  if (micro_hook($micro, $hook)) {
    $base = micro_type_get_module($micro) . '_content';
    $function = $base . '_' . $hook;
    return ($function($micro, $a2, $a3, $a4));
  }
}

/**
 * Prepares a micro object for editing.
 *
 * Fills in a few default values, and then invokes hook_prepare() on the micro
 * type module, and hook_micro_prepare() on all modules.
 */
function micro_object_prepare($micro) {
  // Set up default values, if required.
  //TODO - default options?
  /*
   *$micro_options = variable_get('micro_options_' . $micro->machine_name, array());
   */
  // If this is a new micro, fill in the default values.
  if (!isset($micro->mid) || isset($micro->is_new)) {
    global $user;
    $micro->uid = $user->uid;
    $micro->created = REQUEST_TIME;
  }
  else {
    $micro->date = format_date($micro->created, 'custom', 'Y-m-d H:i:s O');
  }

  micro_invoke($micro, 'prepare');
  module_invoke_all('micro_prepare', $micro);
}

/**
 * Builds a structured array representing the micro's content.
 *
 * The content built for the micro (field values, comments, file attachments or
 * other micro components) will vary depending on the $view_mode parameter.
 *
 * Micro defines the following view modes for micro items, with the following
 * default use cases:
 *   - small (default): micro is being displayed within its parent entity
 *   - full: micro is being displayed on its own page (micro/123)
 *
 * Contributed modules might define additional view modes, or use existing
 * view modes in additional contexts.
 *
 * @param $micro
 *   A micro object.
 * @param $view_mode
 *   View mode, e.g. 'full', 'small'...
 */
function micro_build_content($micro, $view_mode = 'small') {
  // Remove previously built content, if exists.
  $micro->content = array();

  // The 'view' hook can be implemented to overwrite the default function
  // to display micro items.
  if (micro_hook($micro, 'view')) {
    $micro = micro_invoke($micro, 'view', $view_mode);
  }

  // Build fields content.
  // In case of a multiple view, micro_view_multiple() already ran the
  // 'prepare_view' step. An internal flag prevents the operation from running
  // twice.
  field_attach_prepare_view('micro', array($micro->mid => $micro), $view_mode);
  entity_prepare_view('micro', array($micro->mid => $micro));
  $micro->content += field_attach_view('micro', $micro, $view_mode);

  $links = array();
  //TODO - theme callback
  $micro->content['links'] = array(
    '#theme' => 'links__micro',
    '#links' => $links,
    '#attributes' => array('class' => array('links', 'inline')),
  );

  // Allow modules to make their own additions to the micro.
  module_invoke_all('micro_view', $micro, $view_mode);
}

/**
 * Perform validation checks on the given micro.
 */
function micro_validate($micro, $form, &$form_state) {
  $type = micro_type_get_type($micro);

  // Invoke hook_validate() for micro type specific validation and
  // hook_micro_validate() for miscellaneous validation needed by modules. Can't
  // use micro_invoke() or module_invoke_all(), because $form_state must be
  // receivable by reference.
  $function = micro_type_get_module($micro) . '_content_validate';
  if (function_exists($function)) {
    $function($micro, $form, $form_state);
  }
  foreach (module_implements('micro_validate') as $module) {
    $function = $module . '_micro_validate';
    $function($micro, $form, $form_state);
  }
}

/**
 * Prepare micro for saving by populating author and creation date.
 */
function micro_submit($micro) {
  global $user;
  $micro->uid = $user->uid;
  $micro->name = $user->name;
  $micro->created = REQUEST_TIME;
  $micro->validated = TRUE;

  return $micro;
}

/**
 * Generate an array for rendering the given micro.
 *
 * @param $micro
 *   A micro object.
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 *
 * @return
 *   An array as expected by drupal_render().
 */
function micro_view($micro, $view_mode = 'small') {
  // Populate $micro->content with a render() array.
  micro_build_content($micro, $view_mode);
  $micro_type = micro_type_get_type($micro);
  $entity = entity_load($micro_type->entity, array($micro->eid));

  $build = $micro->content;
  // We don't need duplicate rendering info in micro->content.
  unset($micro->content);

  $build += array(
    '#theme' => 'micro',
    '#micro' => $micro,
    '#entity' => reset($entity),
    '#attached_entity_type' => $micro_type->entity,
    '#view_mode' => $view_mode,
  );

  //TODO - test
  // Add contextual links for this micro, except when the micro is already being
  // displayed on its own page. Modules may alter this behavior (for example,
  // to restrict contextual links to certain view modes) by implementing
  // hook_micro_view_alter().
  if (!empty($micro->mid) && !($view_mode == 'full' && micro_is_page($micro))) {
    $build['#contextual_links']['micro'] = array('micro', array($micro->mid));
  }

  // Allow modules to modify the structured micro.
  drupal_alter('micro_view', $build);
  return $build;
}

/**
 * Construct a drupal_render() style array from an array of loaded micro items.
 *
 * @param $micro_items
 *   An array of micro items as returned by micro_load_multiple().
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param $weight
 *   An integer representing the weight of the first micro in the list.
 *
 * @return
 *   An array in the format expected by drupal_render().
 */
function micro_view_multiple($micro_items, $view_mode = 'full', $weight = 0) {
  field_attach_prepare_view('micro', $micro_items, $view_mode);
  entity_prepare_view('micro', $micro_items);
  $build = array();
  foreach ($micro_items as $micro) {
    $build['micro_items'][$micro->mid] = micro_view($micro, $view_mode);
    $build['micro_items'][$micro->mid]['#weight'] = $weight;
    $weight++;
  }
  $build['micro_items']['#sorted'] = TRUE;
  return $build;
}

/**
 * Menu callback; view a single micro.
 */
function micro_page_view($micro) {
  // If there is a menu link to this micro, the link becomes the last part
  // of the active trail, and the link name becomes the page title.
  // Thus, we must explicitly set the page title to be the micro title.
  $type = micro_type_get_type($micro);
  // If there's no view page, go to parent's uri
  if (!$type->data['view_page']) {
    drupal_goto($type->entity . '/' . $micro->eid);
  }
  drupal_set_title($micro->mid);
  $uri = entity_uri('micro', $micro);
  // Set the micro path as the canonical URL to prevent duplicate content.
  drupal_add_html_head_link(array('rel' => 'canonical', 'href' => url($uri['path'], $uri['options'])), TRUE);
  // Set the non-aliased path as a default shortlink.
  drupal_add_html_head_link(array('rel' => 'shortlink', 'href' => url($uri['path'], array_merge($uri['options'], array('alias' => TRUE)))), TRUE);
  return micro_view_multiple(array($micro->mid => $micro));
}


/**
 * Saves a micro type to the db.
 */
function micro_type_save(MicroType $type) {
  /*
   *$type = micro_type_set_defaults($type);
   */
  $type->save();
  drupal_static_reset('_micro_types_build');
}

/**
 * Menu argument loader: loads a micro type by string.
 *
 * @param $name
 *   The machine-readable name of a micro type to load, where '_' is replaced
 *   with '-'.
 *
 * @return
 *   A micro type object or FALSE if $name does not exist.
 */
function micro_type_load($name) {
  return micro_type_get_type(strtr($name, array('-' => '_')));
}

/**
 * Deletes a micro type from the db.
 */
function micro_type_delete(MicroType $type) {
  $type->delete();
  drupal_static_reset('_micro_types_build');
}

/**
 * Set the default values for a micro type.
 *
 * The defaults are for a bundles defined through hook_micro_info().
 *
 * @param $info
 *   An object or array containing values to override the defaults.
 *
 * @return
 *  A micro type object.
 */
function micro_type_set_defaults($info = array()) {
  $type = &drupal_static(__FUNCTION__);

  if (!isset($type)) {
    $type = new MicroType();
    $type->machine_name = '';
    $type->name = '';
    $type->description = '';
    $type->disabled = 0;
    $type->is_new = 1;
  }
  $new_type = clone $type;
  //TODO
  //$info = (array) $info;
  foreach ($info as $key => $data) {
    $new_type->$key = $data;
  }
  if (empty($new_type->module)) {
    $new_type->module = 'micro';
  }

  return $new_type;
}

/**
 * Returns a list of all the available micro types.
 *
 * This list can include types that are queued for addition or deletion.
 * See _micro_types_build() for details.
 *
 * @return
 *   An array of micro types, keyed by the type.
 *
 * @see micro_type_get_type()
 */
function micro_type_get_types($rebuild = FALSE) {
  return _micro_types_build($rebuild)->types;
}

/**
 * Returns the micro type of the passed micro or micro type string.
 *
 * @param $micro
 *   A micro object or string that indicates the micro type to return.
 *
 * @return
 *   A single micro type, as an object, or FALSE if the micro type is not found.
 *   The micro type is an object containing fields from hook_micro_info() return
 *   values, as well as the field 'type' (the machine-readable type) and other
 *   fields used internally and defined in _micro_types_build(),
 *   hook_micro_info(), and micro_type_set_defaults().
 */
function micro_type_get_type($micro, $object = TRUE) {
  if (is_object($micro) || is_numeric($micro)) {
    $id = is_object($micro) ? $micro->mtid : $micro;
    $types = _micro_types_build()->ids;
    return isset($types[$id]) ? ($object ? $types[$id] : $types[$id]->machine_name) : FALSE;
  }
  else {
    $types = _micro_types_build()->types;
    return isset($types[$micro]) ? ($object ? $types[$micro] : $types[$micro]->machine_name) : FALSE;
  }
}

/**
 * Returns the micro type module of the passed micro or micro type string.
 *
 * Indicates which module implements this micro type and is used to
 * execute micro-type-specific hooks.
 *
 * @param $micro
 *   A micro object or string that indicates the micro type to return.
 *
 * @return
 *   The micro type module or FALSE if the micro type is not found.
 *
 * @see micro_invoke()
 */
function micro_type_get_module($micro) {
  if (is_object($micro) || is_numeric($micro)) {
    $id = is_object($micro) ? $micro->mtid : $micro;
    $types = _micro_types_build()->ids;
    return isset($types[$id]) && isset($types[$id]->module) ? $types[$id]->module : FALSE;
  }
  else {
    $types = _micro_types_build()->types;
    return isset($types[$micro]) && isset($types[$micro]->module) ? $types[$micro]->module: FALSE;
  }
}

/**
 * Returns a list of available micro type names.
 *
 * This list can include types that are queued for addition or deletion.
 * See _micro_types_build() for details.
 *
 * @return
 *   An array of micro type names, keyed by the type.
 */
function micro_type_get_names() {
  return _micro_types_build()->names;
}

/**
 * Returns the micro type name of the passed micro or micro type string.
 *
 * @param $micro
 *   A micro object or string that indicates the micro type to return.
 *
 * @return
 *   The micro type name or FALSE if the micro type is not found.
 */
function micro_type_get_name($micro) {
  if (is_object($micro) || is_numeric($micro)) {
    $id = is_object($micro) ? $micro->mtid : $micro;
    $types = _micro_types_build()->ids;
    return isset($names[$id]) && isset($types[$id]->name) ? $types[$id]->name : FALSE;
  }
  else {
    $names = _micro_types_build()->names;
    return isset($names[$micro]) ? $names[$micro] : FALSE;
  }
}

/**
 * Updates the database cache of micro types.
 *
 * All new module-defined micro types are saved to the database via a call to
 * micro_type_save(), and obsolete ones are deleted via a call to
 * micro_type_delete(). See _micro_types_build() for an explanation of the new
 * and obsolete types.
 */
function micro_types_rebuild() {
  _micro_types_build(TRUE);
}

function micro_types_from_entity($entity, $bundle = NULL) {
  $types = array();
  if (isset($bundle)) {
    foreach (micro_type_get_types() as $micro_type) {
      if ($entity == $micro_type->entity && (in_array($bundle, $micro_type->bundles) || empty($micro_type->bundles))) {
        $types[$micro_type->mtid] = $micro_type;
      }
    }
  }
  else {
    foreach (micro_type_get_types() as $micro_type) {
      if ($entity == $micro_type->entity) {
        $types[$micro_type->mtid] = $micro_type;
      }
    }
  }
  return $types;
}


/**
 * Returns information about micro input types from hook_micro_input_info().
 *
 * @param $input_type
 *   (optional) A input type name. If ommitted, all input types will be
 *   returned.
 *
 * @return
 *   Either a single input type description, as provided by
 *   hook_micro_input_info(), or an array of all existing input types, keyed
 *   by input type name.
 */
function micro_input_types($input_type = NULL) {
  $info = _micro_displays_build();
  $input_types = $info['input_types'];
  if ($input_type) {
    if (isset($input_types[$input_type])) {
      return $input_types[$input_type];
    }
  }
  else {
    return $input_types;
  }
}

/**
 * Returns information about micro displays from hook_micro_display_info().
 *
 * @param $display_type
 *   (optional) A display type name. If ommitted, all display types will be
 *   returned.
 *
 * @return
 *   Either a single display type description, as provided by
 *   hook_micro_display_info(), or an array of all existing display types,
 *   keyed by display type name.
 */
function micro_display_types($display_type = NULL) {
  $info = _micro_displays_build();
  $display_types = $info['display_types'];
  if ($display_type) {
    if (isset($display_types[$display_type])) {
      return $display_types[$display_type];
    }
  }
  else {
    return $display_types;
  }
}

/**
 * Builds all information on input types and formatter types for micro items.
 *
 * @param $reset
 *   If TRUE, clear the cache. The information will be rebuilt from the database
 *   next time it is needed. Defaults to FALSE.
 *
 * @return
 *   If $reset is TRUE, nothing.
 *   If $reset is FALSE, an array containing the following elements:
 *   - 'input types': Array of hook_micro_input_info() results, keyed by
 *     input_type. Each element has the following components: label, micro
 *     types, settings, and behaviors from hook_micro_input_info(), as well
 *     as module, giving the module that exposes the input type.
 *   - 'display types': Array of hook_micro_display_info() results, keyed by
 *     display_type. Each element has the following components: label, micro
 *     types, and behaviors from hook_micro_display_info(), as well as
 *     module, giving the module that exposes the display type.
 */
function _micro_displays_build($reset = FALSE) {
  static $info;

  if ($reset) {
    $info = NULL;
    variable_del("micro_display_types");
    return;
  }

  if (!isset($info)) {
    //TODO
      if ($cached = variable_get("micro_view_types")) {
      $info = $cached->data;
    }
    else {
      $info = array(
        'input_types' => array(),
        'display_types' => array(),
      );

      // Populate input types.
      foreach (module_implements('micro_input_info') as $module) {
        $input_types = (array) module_invoke($module, 'micro_input_info');
        foreach ($input_types as $name => $input_info) {
          // Provide defaults.
          $input_info += array(
            'settings' => array(),
          );
          $info['input_types'][$name] = $input_info;
          $info['input_types'][$name]['module'] = $module;
        }
      }
      drupal_alter('micro_input_info', $info['input_types']);

      // Populate display types.
      foreach (module_implements('micro_display_info') as $module) {
        $display_types = (array) module_invoke($module, 'micro_display_info');
        foreach ($display_types as $name => $display_info) {
          // Provide defaults.
          $display_info += array(
            'settings' => array(),
          );
          $info['display_types'][$name] = $display_info;
          $info['display_types'][$name]['module'] = $module;
        }
      }
      drupal_alter('micro_display_info', $info['display_types']);

      variable_set("micro_display_types", $info);
    }
  }

  return $info;
}

/**
 * Builds and returns the list of available micro types.
 *
 * The list of types is built by invoking hook_micro_info() on all modules and
 * comparing this information with the micro types in the {micro_type} table.
 * These two information sources are not synchronized during module installation
 * until micro_types_rebuild() is called.
 *
 * @param $rebuild
 *  TRUE to rebuild micro types. Equivalent to calling micro_types_rebuild().
 * @return
 *   Associative array with two components:
 *   - names: Associative array of the names of micro types, keyed by the type.
 *   - types: Associative array of micro type objects, keyed by the type.
 *   Both of these arrays will include new types that have been defined by
 *   hook_micro_info() implementations but not yet saved in the {micro_type}
 *   table. These are indicated in the type object by $type->is_new being set
 *   to the value 1. These arrays will also include obsolete types: types that
 *   were previously defined by modules that have now been disabled, or for
 *   whatever reason are no longer being defined in hook_micro_info()
 *   implementations, but are still in the database. These are indicated in the
 *   type object by $type->disabled being set to TRUE.
 */
function _micro_types_build($rebuild = FALSE) {
  if (!$rebuild) {
    $_micro_types = &drupal_static(__FUNCTION__);
    if (is_object($_micro_types)) {
      return $_micro_types;
    }
  }

  $_micro_types = (object)array('types' => array(), 'names' => array(), 'ids' => array());

  foreach (module_implements('micro_info') as $module) {
    $info_array = module_invoke($module, 'micro_info');
    foreach ($info_array as $type => $info) {
      $info['type'] = $type;
      $_micro_types->types[$type] = micro_type_set_defaults($info);
      $_micro_types->types[$type]->module = $module;
      $_micro_types->names[$type] = $info['name'];
    }
  }

  $types = $rebuild ? (entity_load('micro_type', FALSE)) : entity_load('micro_type', FALSE, array('disabled' => '0')) ;
  foreach ($types as $type_object) {
    $type_db = $type_object->machine_name;
    // Original disabled value.
    $disabled = $type_object->disabled;
    // Check for micro types from disabled modules and mark their types for removal.
    // Types defined by the micro module in the database (rather than by a separate
    // module using hook_micro_info) have a module value of 'micro'.
    if (isset($type_object->module) && $type_object->module != 'micro' && empty($info_array[$type_db])) {
      $type_object->disabled = TRUE;
    }
    if (isset($info_array[$type_db])) {
      $type_object->disabled = FALSE;
    }
    if (!isset($_micro_types->types[$type_db]) || !isset($_micro_types->types[$type_db]->mtid)) {
      $_micro_types->types[$type_db] = $type_object;
      $_micro_types->names[$type_db] = $type_object->name;
      $_micro_types->types[$type_db]->bundles = $_micro_types->types[$type_db]->bundles;
    }
    $_micro_types->types[$type_db]->disabled = $type_object->disabled;
    $_micro_types->types[$type_db]->disabled_changed = $disabled != $type_object->disabled;
  }

  if ($rebuild) {
    foreach ($_micro_types->types as $type => $type_object) {
      if (!empty($type_object->is_new) || !empty($type_object->disabled_changed)) {
        micro_type_save($type_object);
      }
    }
  }

  // Allow modules implementing hook_micro_alter(&$micro_types) and hook_micro_TYPE_alter(&$micro_type) to modify each micro.
  drupal_alter('micro', $_micro_types->types);
  foreach ($_micro_types->types as $type) {
    drupal_alter('micro_' . $type->machine_name, $type);
    // After types are rebuilt, fill another array keyed by their ids.
    if (isset($type->mtid)) {
      $_micro_types->ids[$type->mtid] = $type;
    }
  }

  asort($_micro_types->names);
  return $_micro_types;
}

function micro_get_display($entity, $id, $view_mode = NULL) {
  $output = array();
  $input = isset($view_mode) ? 'input_' . $view_mode : 'input';
  $display = isset($view_mode) ? 'display_' . $view_mode : 'display';
  $input_types = micro_input_types();
  $display_types = micro_display_types();
  include_once(drupal_get_path('module', 'micro') . '/micro.pages.inc');
  foreach (micro_types_from_entity($entity->content['#entity_type'], $entity->content['#bundle']) as $micro_type) {
    if (isset($micro_type->data['format']) && ($micro_type->data['format'][$input] != 'none' || $micro_type->data['format'][$display] != 'none')) {
      if ($micro_type->data['format'][$display] != 'none') {
        // Load and prepare the micro items
        $micro_items = micro_view_multiple(micro_load_multiple(FALSE, array('mtid' => $micro_type->mtid, 'eid' => $id)));
        $output[$micro_type->machine_name] = array(
          '#entity' => $entity,
          '#eid' => $id,
          '#view_mode' => $view_mode,
          '#items' => reset($micro_items),
          '#bundle' => $micro_type->machine_name,
          '#theme' => $display_types[$micro_type->data['format'][$display]]['theme'],
        );
      }
      if ($micro_type->data['format'][$input] != 'none') {
        $output[$micro_type->machine_name]['input'] = array(
          '#entity' => $entity,
          '#eid' => $id,
          '#view_mode' => $view_mode,
          '#bundle' => $micro_type->machine_name,
          '#theme' => $input_types[$micro_type->data['format'][$input]]['theme'],
        );
      }
    }
  }
  return $output;
}


//============
//MICRO HOOKS.
//============

/**
 * Implements hook_micro_view().
 */
function micro_micro_view($micro, $view_mode) {
  _micro_entity_view($micro, $micro->mid, $view_mode);
}

/**
 * Implements hook_micro_delete()
 */
function micro_micro_delete($micro) {
  _micro_entity_delete('micro', $micro->type, $micro->mid);
}

/**
 * Implements hook_micro_type_delete()
 */
function micro_micro_type_delete($type) {
  // Delete all micro items of this type.
  $mids = array_keys(micro_load_multiple(FALSE, array('mtid' => $type->mtid)));
  micro_delete_multiple($mids);
}

/**
 * Implements hook_micro_access().
 */
function micro_micro_access($micro, $op, $account) {
  // Basic checks
  $type = is_string($micro) ? $micro : $micro->type;
  if (in_array($type, array_keys(micro_type_get_types()))) {
    if ($op == 'create' && user_access('create ' . $type . ' micro items', $account)) {
      return MICRO_ACCESS_ALLOW;
    }
    if ($op == 'update') {
      if (user_access('edit any ' . $type . ' micro items', $account) || (user_access('edit own ' . $type . ' micro items', $account) && ($account->uid == $micro->uid))) {
        return MICRO_ACCESS_ALLOW;
      }
    }
    if ($op == 'delete') {
      if (user_access('delete any ' . $type . ' micro items', $account) || (user_access('delete own ' . $type . ' micro items', $account) && ($account->uid == $micro->uid))) {
        return MICRO_ACCESS_ALLOW;
      }
    }
    // Check for the following cases:
    // - If viewing, check whether the user has access to view the entity.
    // - If editing/deleting, check whether the user has permission and access to the operation on the entity.
    if (($op == 'update' && user_access("edit attached $type micro items", $account)) ||
        ($op == 'delete' && user_access("delete attached $type micro items", $account)) ||
        ($op == 'view')) {
      $micro_type = micro_type_get_type($micro);
      switch ($micro_type->entity) {
        case 'node':
          $entity = node_load($micro->eid);
          dsm($entity);
          if (node_access($op, $entity, $account)) {
            return MICRO_ACCESS_ALLOW;
          }
          break;
        case 'user':
          $entity = user_load($micro->eid);
          if (($op != 'view' && user_edit_access($entity)) || ($op == 'view' && user_access('access user profiles', $account))) {
            return MICRO_ACCESS_ALLOW;
          }
          break;
        case 'comment':
          $entity = comment_load($micro->eid);
          if (comment_access($op, $entity)) {
            return MICRO_ACCESS_ALLOW;
          }
          break;
        case 'taxonomy':
          $vocabulary = taxonomy_get_vocabulary($micro->eid);
          // Since taxonomy doesn't have authorship, we check for editorial rights.
          if (($op !== 'view' && user_access($op . ' terms ' . ($op == 'edit' ? 'in ' : 'from ') . $vocabulary)) ||
              ($op == 'view')) {
            return MICRO_ACCESS_ALLOW;
          }
          break;
      }
    }
  }
  return MICRO_ACCESS_IGNORE;
}

/**
 * Implements hook_micro_display_info()
 */
function micro_micro_display_info() {
  return array(
    /*
     *'simple_page_display' => array(
     *  'label' => t('Simple page'),
     *  'micro_types' => array(),
     *  'theme' => 'micro_simple_page_display',
     *),
     */
    'wrapper' => array(
      'label' => t('Inline'),
      'micro_types' => array(),
      'theme' => 'micro_wrapper',
    ),
    'test_display' => array(
      'label' => t('Test'),
      'micro_types' => array('status' => 'status'),
      'theme' => 'micro_test_display',
    ),
  );
}

/**
 * Implements hook_micro_input_info()
 */
function micro_micro_input_info() {
  return array(
    /*
     *'simple_page_input' => array(
     *  'label' => t('Simple page'),
     *  'micro_types' => array(),
     *  'theme' => 'micro_simple_page_input',
     *),
     */
    'linked_page_input' => array(
      'label' => t('Linked page'),
      'micro_types' => array(),
      'theme' => 'micro_linked_page_input',
    ),
    'ajax_form_input' => array(
      'label' => t('Ajax form'),
      'micro_types' => array(),
      'theme' => 'micro_ajax_form_input',
    ),
    'inline_form_input' => array(
      'label' => t('Inline form'),
      'micro_types' => array(),
      'theme' => 'micro_inline_form_input',
    ),
    'test_form_input' => array(
      'label' => t('test input'),
      'micro_types' => array('status' => 'status'),
      'required' => TRUE,
      'theme' => 'micro_test_form_input',
    ),
  );
}


//=================
//HELPER FUNCTIONS.
//=================

/**
 * Entity uri callback.
 */
function micro_uri($micro) {
  return array(
    'path' => 'micro/' . $micro->mid,
  );
}
/**
 * Returns whether the current page is the full page view of the passed in micro.
 *
 * @param $micro
 *   A micro object.
 */
function micro_is_page($micro) {
  $page_element = menu_get_object();
  return (!empty($page_element) ? (isset($page_element->mid) && $page_element->mid == $micro->mid) : FALSE);
}

function micro_page_title($micro) {
  return isset($micro->mid) ? $micro->mid : '';
}
/**
 * Menu title callback.
 */
function micro_type_page_title($micro_type) {
  return $micro_type->machine_name;
}

/**
 * Content type checking to see if a micro applies to a certain type of data.
 *
 * @param $micro
 *   The micro object whose available types are being checked.
 * @param $entity
 *   The entity being checked, usually "node".
 * @param $bundle
 *   The subtype being checked.
 *
 * @return
 *   Boolean TRUE if the micro is enabled for this entity and bundle.
 *   FALSE otherwise.
 */
function micro_content_enabled($micro_type, $entity, $bundle = NULL) {
  $return = $micro_type->entity == $entity && (!isset($bundle) || in_array($bundle, $micro_type->bundles));
  return $return;
}

/**
 * Returns an array with entity labels, bundles, and view modes.
 */
function micro_get_entities($object = TRUE) {
  if ($object) {
    $entities['site'] = array('label' => t('Site'), 'bundles' => array('site' => 'Site'));
    foreach (entity_get_info() as $entity => $data) {
      if ($data['fieldable']) {
        $entities[$entity] = array('label' => $data['label']);
        foreach ($data['bundles'] as $bundle => $info) {
         $entities[$entity]['bundles'][$bundle] = $info['label'];
        }
        foreach ($data['view modes'] as $mode => $info) {
         $entities[$entity]['modes'][$mode] = $info['label'];
        }
      }
    }
  }
  else {
    $entities['site'] = t('Site');
    foreach (entity_get_info() as $entity => $data) {
      if ($data['fieldable']) {
        $entities[$entity] = $data['label'];
      }
    }
  }
  return $entities;
}

function _micro_entity_view($entity, $eid, $view_mode) {
  $displays = micro_get_display($entity, $eid, $view_mode);
  foreach ($displays as $key => $value) {
    $entity->content[$key] = $value;
  }
}

function _micro_entity_delete($entity_name, $entity_type, $eid) {
  $types = micro_types_from_entity($entity_name, $entity_type);
  //TODO - not sure conditions accept arrays
  foreach (micro_load_multiple(FALSE, array('mtid' => array_keys($types), 'eid' => $eid)) as $micro) {
     micro_delete($micro);
  }
}

/**
 * Theme callback for creating and editing micro items.
 */
function _micro_custom_theme() {
  // Use the administration theme if the site is configured to use it for
  // micro items.
  if (variable_get('micro_admin_theme')) {
    return variable_get('admin_theme');
  }
}

function _micro_add_access() {
  $types = micro_type_get_types();
  foreach ($types as $type) {
    if (micro_hook($type->machine_name, 'form') && micro_access('create', $type->machine_name)) {
      return TRUE;
    }
  }
  if (user_access('administer micro types')) {
    // There are no micro types defined that the user has permission to create,
    // but the user does have the permission to administer the micro types, so
    // grant them access to the page anyway.
    return TRUE;
  }
  return FALSE;
}


//======
//FORMS.
//======

/**
 * Implements hook_form().
 */
function micro_content_form($micro, $form_state) {
  // It is impossible to define a content type without implementing hook_form()
  // @todo: remove this requirement.
  $form = array();
  return $form;
}


//================
//THEME FUNCTIONS.
//================

/**
 * Process variables for micro.tpl.php
 *
 * Most themes utilize their own copy of micro.tpl.php. The default is located
 * inside "modules/micro/micro.tpl.php". Look in there for the full list of
 * variables.
 *
 * The $variables array contains the following arguments:
 * - $micro
 * - $view_mode
 * - $page
 *
 * @see micro.tpl.php
 */
function template_preprocess_micro(&$variables) {
  $variables['micro'] = $variables['elements']['#micro'];
  $micro = $variables['micro'];
  $variables['micro_type'] = micro_type_get_type($micro);
  $micro_type = $variables['micro_type'];
  $variables['view_mode'] = $variables['elements']['#view_mode'];
  $variables['entity'] = $variables['elements']['#entity'];
  $variables['date']      = format_date($micro->created);
  $variables['name']      = theme('username', array('account' => $micro));
  $uri = entity_uri('micro', $micro);
  $variables['micro_url']  = url($uri['path'], $uri['options']);
  $variables['title']      = $micro->mid;
  $variables['page']       = $variables['view_mode'] == 'full' && micro_is_page($micro);

  // Flatten the micro object's member fields.
  $variables = array_merge((array) $micro, $variables);

  // Helpful $content variable for templates.
  foreach (element_children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }

  // Make the field variables available with the appropriate language.
  field_attach_preprocess('micro', $micro, $variables['content'], $variables);

  //TODO
  // Display post information only on certain micro types.
  if (variable_get('micro_submitted_' . $micro_type->machine_name, TRUE)) {
    $variables['display_submitted'] = TRUE;
    $variables['user_picture'] = theme_get_setting('toggle_micro_user_picture') ? theme('user_picture', array('account' => $micro)) : '';
  }
  else {
    $variables['display_submitted'] = FALSE;
    $variables['user_picture'] = '';
  }

  // Gather micro classes.
  $variables['classes_array'][] = drupal_html_class('micro-' . $micro_type->machine_name);

  // Clean up name so there are no underscores.
  $variables['theme_hook_suggestions'][] = 'micro__' . $micro_type->machine_name;
  $variables['theme_hook_suggestions'][] = 'micro__' . $micro->mid;
}

/**
 * Process variables for micro-wrapper.tpl.php.
 *
 * @see micro-wrapper.tpl.php
 * @see theme_micro_wrapper()
 */
function template_preprocess_micro_wrapper(&$variables) {
  // Provide contextual information.
  $bundle = $variables['elements']['#bundle'];
  $variables['entity'] = $variables['elements']['#entity'];
  $variables['bundle'] = $bundle;
  /*
   *$variables['display_mode'] = variable_get('micro_default_mode_' . $variables['node']->type, micro_MODE_THREADED);
   */
  // Clean up name so there are no underscores.
  $variables['theme_hook_suggestions'][] = 'micro_wrapper__' . $bundle;
}
function theme_micro_inline_form_input($variables) {
  $elements = $variables['elements'];
  return drupal_render(micro_add($elements['#bundle'], $elements['#eid']));
}

function theme_micro_linked_page_input($variables) {
  $elements = $variables['elements'];
  /*
   *return l(t("Add a new @type", array('@type' => $elements['#micro_type']['name'])), 'micro/add/' . str_replace('_', '-', $form['form']['#micro_type']['machine_name']) . '/' . $form['form']['eid']['#value']);
   */
}

function theme_micro_ajax_form_input($variables) {
  drupal_add_js('misc/ajax.js');
  $elements = $variables['elements'];
  $bundle = str_replace('_', '-', $elements['#bundle']);
  $dash = $bundle . '-' . $elements['#eid'];
  $slash = $bundle . '/' . $elements['#eid'];
  $name = str_replace('-', ' ', $bundle);
  $output = l(t('Add a new @type', array('@type' => $name)), 'micro/ajax/add/nojs/' . $slash . '/open',
    array('attributes' => array('class' => array('use-ajax'), 'id' => array('micro-add-' . $dash))));
  return $output;
}

function micro_ajax_add($type = 'ajax', $micro_type, $eid, $op = close) {
  if ($type == 'ajax') {
    $bundle = str_replace('_', '-', $micro_type->machine_name);
    $dash = $bundle . '-' . $eid;
    $slash = $bundle . '/' . $eid;
    $name = str_replace('-', ' ', $bundle);
    $id = 'micro-add-' . $dash;
    $commands = array();
    if ($op == 'open') {
      include_once(drupal_get_path('module', 'micro') . '/micro.pages.inc');
      $link = l(t('Close'), 'micro/ajax/add/nojs/' . $slash . '/close',
        array('attributes' => array('class' => array('use-ajax'), 'id' => array('micro-add-' . $dash . '-link'))));
      $form = drupal_render(micro_add($micro_type->machine_name, $eid));
      $output = '<div id="' . $id . '">' . $link . $form . '</div>';
    }
    else {
      $output = l(t('Add a new @type', array('@type' => $name)), 'micro/ajax/add/nojs/' . $slash . '/open',
        array('attributes' => array('class' => array('use-ajax'), 'id' => array('micro-add-' . $dash))));
    }
    $commands[] = ajax_command_replace('#' . $id, $output);
    $page = array('#type' => 'ajax', '#commands' => $commands);
    ajax_deliver($page);
  }
  else {
    $output = t("This is some content delivered via a page load.");
    return $output;
  }
}


//==================
//VIEWS INTEGRATION.
//==================

/**
 * Implements hook_views_api().
 * TODO
 */
function micro_views_api() {
  return array(
    'api' => '3.0-alpha1',
    'path' => drupal_get_path('module', 'micro') . '/includes',
  );
}


//===================
//ACTION INTEGRATION.
//===================

/**
 * Implements hook_action_info().
 * TODO - micro_delete_action
 * TODO - micro_delete_from_user_action
 * TODO - micro_change_eid_action
 * TODO - micro_change_user_action
 */
function micro_action_info() {
  return array(
    'micro_save_action' => array(
      'type' => 'micro',
      'label' => t('Save content'),
      'configurable' => FALSE,
      'triggers' => array('comment_insert', 'comment_update', 'comment_delete'),
    ),
  );
}

/**
 * Saves a micro.
 *
 * @ingroup actions
 */
function micro_save_action($micro) {
  micro_save($micro);
  watchdog('action', 'Saved @type %id', array('@type' => micro_type_get_name($micro), '%title' => $micro->mid));
}


/**
 * Gather the rankings from the the hook_ranking implementations.
 *
 * @param $query
 *   A query object that has been extended with the Search DB Extender.
 */
function _micro_rankings(SelectQueryExtender $query) {
  if ($ranking = module_invoke_all('ranking')) {
    $tables = &$query->getTables();
    foreach ($ranking as $rank => $values) {
      if ($micro_rank = variable_get('micro_rank_' . $rank, 0)) {
        // If the table defined in the ranking isn't already joined, then add it.
        if (isset($values['join']) && !isset($tables[$values['join']['alias']])) {
          $query->addJoin($values['join']['type'], $values['join']['table'], $values['join']['alias'], $values['join']['on']);
        }
        $arguments = isset($values['arguments']) ? $values['arguments'] : array();
        $query->addScore($values['score'], $arguments, $micro_rank);
      }
    }
  }
}

/**
 * Implements hook_search_info().
 */
function micro_search_info() {
  return array(
    'title' => 'Content',
    'path' => 'micro',
  );
}

/**
 * Implements hook_search_access().
 */
function micro_search_access() {
  return user_access('access content');
}

/**
 * Implements hook_search_reset().
 */
function micro_search_reset() {
  db_update('search_dataset')
    ->fields(array('reindex' => REQUEST_TIME))
    ->condition('type', 'micro')
    ->execute();
}

/**
 * Implements hook_search_status().
 */
function micro_search_status() {
  $total = db_query('SELECT COUNT(*) FROM {micro}')->fetchField();
  $remaining = db_query("SELECT COUNT(*) FROM {micro} n LEFT JOIN {search_dataset} d ON d.type = 'micro' AND d.sid = n.nid WHERE d.sid IS NULL OR d.reindex <> 0")->fetchField();
  return array('remaining' => $remaining, 'total' => $total);
}

/**
 * Implements hook_search_admin().
 */
function micro_search_admin() {
  // Output form for defining rank factor weights.
  $form['content_ranking'] = array(
    '#type' => 'fieldset',
    '#title' => t('Content ranking'),
  );
  $form['content_ranking']['#theme'] = 'micro_search_admin';
  $form['content_ranking']['info'] = array(
    '#value' => '<em>' . t('The following numbers control which properties the content search should favor when ordering the results. Higher numbers mean more influence, zero means the property is ignored. Changing these numbers does not require the search index to be rebuilt. Changes take effect immediately.') . '</em>'
  );

  // Note: reversed to reflect that higher number = higher ranking.
  $options = drupal_map_assoc(range(0, 10));
  foreach (module_invoke_all('ranking') as $var => $values) {
    $form['content_ranking']['factors']['micro_rank_' . $var] = array(
      '#title' => $values['title'],
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => variable_get('micro_rank_' . $var, 0),
    );
  }
  return $form;
}

/**
 * Implements hook_search_execute().
 */
function micro_search_execute($keys = NULL, $conditions = NULL) {
  // Build matching conditions
  $query = db_select('search_index', 'i', array('target' => 'slave'))->extend('SearchQuery')->extend('PagerDefault');
  $query->join('micro', 'n', 'n.nid = i.sid');
  $query
    ->condition('n.status', 1)
    ->addTag('micro_access')
    ->searchExpression($keys, 'micro');

  // Insert special keywords.
  $query->setOption('type', 'n.type');
  $query->setOption('language', 'n.language');
  if ($query->setOption('term', 'ti.tid')) {
    $query->join('taxonomy_index', 'ti', 'n.nid = ti.nid');
  }
  // Only continue if the first pass query matches.
  if (!$query->executeFirstPass()) {
    return array();
  }

  // Add the ranking expressions.
  _micro_rankings($query);

  // Load results.
  $find = $query
    ->limit(10)
    ->execute();
  $results = array();
  foreach ($find as $item) {
    // Render the micro.
    $micro = micro_load($item->sid);
    $build = micro_view($micro, 'search_result');
    unset($build['#theme']);
    $micro->rendered = drupal_render($build);

    // Fetch comments for snippet.
    $micro->rendered .= ' ' . module_invoke('comment', 'micro_update_index', $micro);

    $extra = module_invoke_all('micro_search_result', $micro);

    $uri = entity_uri('micro', $micro);
    $results[] = array(
      'link' => url($uri['path'], array_merge($uri['options'], array('absolute' => TRUE))),
      'type' => check_plain(micro_type_get_name($micro)),
      'title' => $micro->title,
      'user' => theme('username', array('account' => $micro)),
      'date' => $micro->changed,
      'micro' => $micro,
      'extra' => $extra,
      'score' => $item->calculated_score,
      'snippet' => search_excerpt($keys, $micro->rendered),
    );
  }
  return $results;
}

/**
 * Implements hook_ranking().
 */
function micro_ranking() {
  // Create the ranking array and add the basic ranking options.
  $ranking = array(
    'relevance' => array(
      'title' => t('Keyword relevance'),
      // Average relevance values hover around 0.15
      'score' => 'i.relevance',
    ),
    'sticky' => array(
      'title' => t('Content is sticky at top of lists'),
      // The sticky flag is either 0 or 1, which is automatically normalized.
      'score' => 'n.sticky',
    ),
    'promote' => array(
      'title' => t('Content is promoted to the front page'),
      // The promote flag is either 0 or 1, which is automatically normalized.
      'score' => 'n.promote',
    ),
  );

  // Add relevance based on creation or changed date.
  if ($micro_cron_last = variable_get('micro_cron_last', 0)) {
    $ranking['recent'] = array(
      'title' => t('Recently posted'),
      // Exponential decay with half-life of 6 months, starting at last indexed micro
      'score' => 'POW(2.0, (GREATEST(n.created, n.changed) - :micro_cron_last) * 6.43e-8)',
      'arguments' => array(':micro_cron_last' => $micro_cron_last),
    );
  }
  return $ranking;
}

